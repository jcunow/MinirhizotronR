[{"path":[]},{"path":[]},{"path":"https://jcunow.github.io/MinirhizotronR/articles/MinirhizotronR.html","id":"guide-on-how-to-use-this-package","dir":"Articles","previous_headings":"","what":"Guide on how to use this package:","title":"MinirhizotronR: Depth Resolved Analysis of Segmented Minirhizotron Scans","text":"MinirhizotronR picks work left behind root scans segemented root pixel, background pixel, others identified. find suggestions get point . strongly recommend calibrating tubes -situ note insertion angle, tube diameter, soil start relation scan starts every tube (perhaps timepoints movment expected). calibration guide follow point.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/articles/MinirhizotronR.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"MinirhizotronR: Depth Resolved Analysis of Segmented Minirhizotron Scans","text":"","code":"# devtools::install_github(\"jcunow/MinirhizotronR\") # remotes::install_github(\"jcunow/MinirhizotronR\")"},{"path":"https://jcunow.github.io/MinirhizotronR/articles/MinirhizotronR.html","id":"image-stitching","dir":"Articles","previous_headings":"","what":"Image stitching","title":"MinirhizotronR: Depth Resolved Analysis of Segmented Minirhizotron Scans","text":"longer Minirhizotron tubes one scan doesn’t trick need scan several depths. case ’ll end set images tube time point. purposes, might want stitch together remove overlap. enable us arrive quasi-continues depth distribution. Stitch segmentation - can find two solution : Affine Keyfeature Stitching Scans corresponding particular Tube Time; see Try AffineStitcher.py StitchR repository. Works well feature rich images overlap less good homogeneous images little overlap. Limiting key feature mapping overlap region result better results (implemented yet!) https://github.com/jcunow/ImageStitching Use ImageJ’s Addon Stitcher. Needs text file listing rough Image positions (ca. 100px overlap). high successrate time intensive.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/articles/MinirhizotronR.html","id":"ai-image-segmentation","dir":"Articles","previous_headings":"","what":"AI Image segmentation","title":"MinirhizotronR: Depth Resolved Analysis of Segmented Minirhizotron Scans","text":"Image segmentation critical processing. several options available: Distinguishing root background essential. Two potential choices: “RootDetector” applied stitched Images; software return segmented skeletonized Image information stored different channels. RootDetector allows distinguish tape, roots, background using root identification method. Peters et al. (2023) good much efficient reproducible human experts detecting plant roots minirhizotron images: Convolution Neural Network RootDetector Scientific Reports 13 1, Using root tracking return root production, root decay, -change roots. Using unlocks additional Turnover estimation - Turnover.DPC() Gillert et al. 2023, Tracking Growth Decay Plant Roots Minirhizotron Images. IEEE/CVF Winter Conference Applications Computer Vision (WACV), https://doi.org/10.1109/WACV56688.2023.00369 Software https://github.com/ExPlEcoGreifswald/RootDetector “RootPainter” applied stitched Images; software returns segmented Image. Smith et al. 2022, RootPainter: deep learning segmentation biological images corrective annotation, New Phytologist 236 2, https://doi.org/10.1111/nph.18387 Software https://github.com/Abe404/root_painter Tipp: split stitched images root detection algorithm trouble amount roots roots. can rejoin segmented images afterwards. first, look settings can changed crank maximum root limit. root stitched root scan may look like:  segmentation, get pixel group information different layers looking somthing like : many purposes, need skeleton version segmentation:","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/articles/MinirhizotronR.html","id":"lets-look-at-example-input","dir":"Articles","previous_headings":"","what":"Let’s look at example input","title":"MinirhizotronR: Depth Resolved Analysis of Segmented Minirhizotron Scans","text":"First, need load images. example images taken sedge fen north eastern Finland Oulanka National Park.","code":"library(MinirhizotronR) library(dplyr) library(terra)  # read color image, segmented, and skeletonized data(rgb_Oulanka2023_Session03_T067) data(seg_Oulanka2023_Session03_T067) data(skl_Oulanka2023_Session01_T067) data(skl_Oulanka2023_Session03_T067) data(TurnoverDPC_data)  seg_Oulanka2023_Session03_T067 = terra::rast(seg_Oulanka2023_Session03_T067) rgb_Oulanka2023_Session03_T067 = terra::rast(rgb_Oulanka2023_Session03_T067) skl_Oulanka2023_Session01_T067 = terra::rast(skl_Oulanka2023_Session01_T067) skl_Oulanka2023_Session03_T067 = terra::rast(skl_Oulanka2023_Session03_T067) TurnoverDPC_data = terra::rast(TurnoverDPC_data) #skl_Oulanka2023_Session03_T067 = (skeletonize(seg_Oulanka2023_Session03_T067[[2]], itr= 3))"},{"path":"https://jcunow.github.io/MinirhizotronR/articles/MinirhizotronR.html","id":"calibration","dir":"Articles","previous_headings":"","what":"Calibration","title":"MinirhizotronR: Depth Resolved Analysis of Segmented Minirhizotron Scans","text":"’s important know scans relate soil depth tube upside face located image. assume don’t -situ calibration available. Instead, going give best guess soil surface position rotation center position using tape cover position proxy.","code":"### If you have measured the the distance from the soil to the edge of the tube - great, your job is done!  ## Just do this: height = 12 # cm tilt = 45 # insertion angle dpi = 150 # imiage resolution  # law of sines radiant = pi/180 s0.true = (sin((90) * radiant)*height) / sin(tilt * radiant) s0 = s0.true * dpi / 2.54 s0 = s0 %>% round()   ### If you don't have any calibration data available - too bad! ## Try this instead: # Based on Tape Cover, soil start is estimated s0 = MinirhizotronR::SoilSurfE(rgb_Oulanka2023_Session03_T067) print(paste0(\"Soil Surface Beginning in columns: \",s0$soil0)) #> [1] \"Soil Surface Beginning in columns: 379\" # While we're at it, lets estimate the rotion center (Here, we assume that the tape extrusion on the upside of the Tube is perfectly centered - go and calibrate !!!) r0 = MinirhizotronR::RotationE(rgb_Oulanka2023_Session03_T067) print(paste0(\"Rotation Center in rows: \",r0)) #> [1] \"Rotation Center in rows: 436.5\""},{"path":"https://jcunow.github.io/MinirhizotronR/articles/MinirhizotronR.html","id":"depth-map","dir":"Articles","previous_headings":"","what":"Depth Map","title":"MinirhizotronR: Depth Resolved Analysis of Segmented Minirhizotron Scans","text":"ready now create depth map. goal supply every pixel root scans depth information. choose include tube thickness thereby create phase shifted cosine depth map - ignore (traditionally done). Ignoring create map tube upside located depth tube downside (= vertical insertion angle).","code":"## We want to exclude pixels with tape as part of the soil. Create a mask: # The format of 'RootDetector' uses the red channel to show mask and root px, while blue and green only show root px mask = (seg_Oulanka2023_Session03_T067[[1]] - seg_Oulanka2023_Session03_T067[[2]] ) / 255 mask = terra::t(mask) ## Create the Map  center.offset = r0  / dim(seg_Oulanka2023_Session03_T067)[1] DepthMap = create.depthmap(im = seg_Oulanka2023_Session03_T067,                             sinoid = TRUE,                             mask = mask,start.soil = s0$soil0,                            center.offset = center.offset )  # Now lets bin the depth to be able to calculate some stats. Analysis on continuous depth will feature in a future release. # we use 5cm intervals here but any bandwidth can be used. bm = MinirhizotronR::binning(DepthMap, nn = 2, \"rounding\") terra::ext(bm) <- c(0,dim(bm)[2],0,dim(bm)[1]) # Binned Depthmap Plot tbm = terra::t(bm) terra::plot(tbm)"},{"path":"https://jcunow.github.io/MinirhizotronR/articles/MinirhizotronR.html","id":"extract-root-scape-features","dir":"Articles","previous_headings":"","what":"Extract Root Scape Features","title":"MinirhizotronR: Depth Resolved Analysis of Segmented Minirhizotron Scans","text":"Depth Information ready, can now analyze data. , interested 3 key features: Root Coverage, RootScapes Features, Peat Characteristics. Let’s get :","code":"# A good starting point is selecting the desired depth. Typically, you want to go through all depth to construct a depth distribution. For brevity, we show it for one depth here.  ## We only need one binarized layer # one layer gray would usually be a good option, however, there is distinct information stored in the various layers when using 'RootDetector' gray.roots = rgb2gray(seg_Oulanka2023_Session03_T067) # In this format, we can simply do this: gray.roots = seg_Oulanka2023_Session03_T067[[2]]  terra::ext(gray.roots) <- c(0,dim(gray.roots)[2],0,dim(gray.roots)[1])  # extracts a depth band from the root image based on the depth map  rootzone = zone.fun(rootpic = gray.roots, binned.map = bm, indexD = -10, nn = 2 ) #> [1] \"Depth: -10cm. Not enough informative pixels. In the whole Image, 100% are NAs after cutting this Depth Slice. Expected NA% is: ~93.33\" # the output message tells us the there are not enough proper values in the root zone. Lets try again rootzone = zone.fun(rootpic = gray.roots, binned.map = bm, indexD = 8, nn = 2 ) terra::plot(rootzone) # Also do it for the skeletonized version rootzone.skeleton = zone.fun(skl_Oulanka2023_Session03_T067, binned.map = bm, indexD = 20, nn = 2) terra::ext(rootzone.skeleton) <- c(0,dim(rootzone.skeleton)[2],0,dim(rootzone.skeleton)[1])   # Get the landscape metrics of the root scape - keep the output units in mind (assuming... input and deliver hectar output) rsm = RootScapeMetrics(rootzone,indexD = 8, metrics = c( \"lsm_c_ca\",\"lsm_l_ent\",\"lsm_c_pd\",                                       \"lsm_c_enn_mn\"))  print(rsm)  #> # A tibble: 4 × 4 #>   metric    value object depth #>   <chr>     <dbl> <chr>  <dbl> #> 1 ca        3.86  root       8 #> 2 enn_mn    2.05  root       8 #> 3 pd     4739.    root       8 #> 4 ent       0.468 root       8"},{"path":"https://jcunow.github.io/MinirhizotronR/articles/MinirhizotronR.html","id":"exctract-common-parameter","dir":"Articles","previous_headings":"","what":"Exctract Common Parameter","title":"MinirhizotronR: Depth Resolved Analysis of Segmented Minirhizotron Scans","text":"Get real numbers coverage numbers now","code":"# Get number of Root pixel and Root Length, and Root Thickness void = 255-(gray.roots) # check if extent matches  # rotate if necessary if(all(dim(bm)[1:2] != dim(gray.roots)[1:2])){ bm = terra::t(bm)   }  # retrieve the root pixel sum and the pixel without roots for all depths void.sum = terra::zonal( void,bm, \"sum\" ) root.sum = terra::zonal(gray.roots,bm,\"sum\")  colnames(void.sum) <- c(\"zone\",\"sum\") colnames(root.sum) <- c(\"zone\",\"sum\")  # if you want to include this function within a depth wise loop use this rootpixel = px.sum(root.zone = rootzone) # uses the segmented - so its total root pixel   # for root length do something like this kimroot = RootLength(rootzone.skeleton) # lastly Root thickness root.thicc = root.thickness(kimuralength = kimroot, rootpx = rootpixel, dpi = 150)  ## report: print(paste0(\"total root pixel in this depth: \",rootpixel,\" px\")) #> [1] \"total root pixel in this depth: 38622 px\" print(paste0(\"total root length in this depth: \",kimroot,\" cm\")) #> [1] \"total root length in this depth: NaN cm\" print(paste0(\"average root thickness in this depth: \",root.thicc,\" cm\")) #> [1] \"average root thickness in this depth: NaN cm\""},{"path":"https://jcunow.github.io/MinirhizotronR/articles/MinirhizotronR.html","id":"correct-for-margins","dir":"Articles","previous_headings":"","what":"Correct for Margins","title":"MinirhizotronR: Depth Resolved Analysis of Segmented Minirhizotron Scans","text":"OBS! depth equal amount tube surface display roots! end pieces tilted tube partially tape covered tube smaller tube surface","code":"# correct for available space av.space = root.sum + void.sum av.space[,1] =  av.space[,1]/2 plot(av.space) + title(\"total available rooting space\") #> integer(0)  rootpx_per_av.space =  root.sum rootpx_per_av.space[,2] = root.sum[,2] / av.space[,2] df.rootpx_per_av.space = as.data.frame(rootpx_per_av.space) ggplot(data=df.rootpx_per_av.space,aes(zone,sum)) + geom_point() + geom_smooth(span=0.25) + theme_classic() + ylab(\"% covered by roots\") + xlab(\"Depth [cm]\") +ggtitle(\"Roots per available rooting space\") #ggsave(\"C:/Users/jocu0013/Documents/GitHub/MinirhizotronR/figures/rootsperavailablespace.png\")"},{"path":"https://jcunow.github.io/MinirhizotronR/articles/MinirhizotronR.html","id":"rootsphere-influence","dir":"Articles","previous_headings":"","what":"Rootsphere Influence","title":"MinirhizotronR: Depth Resolved Analysis of Segmented Minirhizotron Scans","text":"want consider sphere influence around roots ?","code":"## set hard limits root.seg = gray.roots  terra::values(root.seg)[terra::values(terra::t(mask))==1] <- NA  # create a buffer around pixels (12 px == ca. 1mm), Rhizophere exudates 2mm (source) buff.im = Halo(root.seg, width = 2, halo.only = FALSE) terra::plot(buff.im, main= \"The sphere of influence (roots + 0.3mm each side)\") ## lets do some stats on the sphere of influence buffer.sum = terra::zonal( buff.im,bm, \"sum\",na.rm=TRUE ) plot(scale(buffer.sum)); points(scale(root.sum),col=\"red\") + title(\"The difference between distribution of influence (black) vs distribution of rotos (red)\") #> integer(0)  # Hint: sphere of influence might not be the same across depth with varying physiology and hydraulic conductivity"},{"path":"https://jcunow.github.io/MinirhizotronR/articles/MinirhizotronR.html","id":"estimate-soil-parameter","dir":"Articles","previous_headings":"","what":"Estimate Soil Parameter","title":"MinirhizotronR: Depth Resolved Analysis of Segmented Minirhizotron Scans","text":"Can characterize Peat ?","code":"# only consider soil pixels - not tape nor roots peat.color = terra::crop(rgb_Oulanka2023_Session03_T067,gray.roots) terra::values(peat.color)[terra::values(buff.im) == 1] = NA  terra::values(peat.color)[terra::values(terra::t(mask)) == 1] = NA  # plot & color terra::plotRGB(peat.color) tube.color.peat = Tube.coloration(peat.color);tube.color.peat #>      rcc    gcc    bcc        hue saturation luminosity      red    green #> 1 0.4537 0.3038 0.2424 0.04923419  0.4441139  0.1709672 43.59664 29.95436 #>       blue #> 1 24.23477   # now only consider roots root.color = terra::crop(rgb_Oulanka2023_Session03_T067,gray.roots) terra::values(root.color)[terra::values(gray.roots) == 0] = NA  terra::values(root.color)[terra::values(terra::t(mask)) == 1] = NA  # plot & color terra::plotRGB(root.color, main = \"available root pixel\") tube.color.root = Tube.coloration(root.color);tube.color.root #>      rcc    gcc    bcc        hue saturation luminosity      red    green #> 1 0.4126 0.3182 0.2692 0.05777937  0.3207919  0.2450358 62.48412 49.38863 #>       blue #> 1 42.43972  ##  Lets try to get texture information as well gray.peat = raster::raster(rgb2gray(peat.color)) void.tx = glcm::glcm(gray.peat,n_grey = 7,window = c(9,9),                       statistics = c(\"second_moment\",\"homogeneity\"),                      shift=list(c(0,1), c(1,1), c(1,0), c(1,-1))) #void.tx = terra::rast(void.tx) terra::plot(void.tx[[1]], main = \"available texture pixels and their second moment characteristic\") ## extent don't match bm2 = raster::brick(bm) terra::ext(bm) = terra::ext(void.tx)  tx.mean = terra::zonal(void.tx,bm2) plot(tx.mean) + title(\"second moment - peat texture characterization\") #> integer(0)"},{"path":"https://jcunow.github.io/MinirhizotronR/articles/MinirhizotronR.html","id":"rotational-bias","dir":"Articles","previous_headings":"","what":"Rotational Bias","title":"MinirhizotronR: Depth Resolved Analysis of Segmented Minirhizotron Scans","text":"tube insertion angle increases, expect differences upside tube downside. Let’s estimate rotational bias","code":"# remove artefacts root.seg.c = RotCensor(root.seg,fixed.width = 1000) # lets make the split in 0.5 cm intervals dpi = 150 splits = round(dim(root.seg)[1]/dpi*2.54) * 2 rot.df = data.frame(rotation = 1:splits,rotation.rootpx = NA)  for (k in 1:splits) { rotation.z = zone.rotation.fun(rootpic = root.seg, mm= c(1500,4000), kk = splits, k = c(k-1,k))   rot.df[k,2] = px.sum(root.zone = rotation.z) } rot.df$sc.rotationpx = scale(rot.df$rotation.rootpx) ggplot(data= rot.df, aes(rotation,sc.rotationpx)) +    geom_point() +     theme_bw() + xlab(\"rotation cm\") + ylab(\"root px\") +    geom_smooth(method=\"lm\", formula = y ~ cos(x*pi/16),aes(color = \"cosine fit\")) +    geom_smooth(se=F,aes(color=\"local smooth\"),span = 0.5) ## fit a sine curve to the rotation-sliced image fitSinCurve(tt=rot.df$rotation,yy=rot.df$sc.rotationpx) #> $amp #> [1] 0.8639946 #>  #> $phase #> [1] 11.30286 #>  #> $offset #> [1] 0.1276436 #>  #> $peak #> [1] -5.302862 #>  #> $A #> [1] -0.8496447 #>  #> $B #> [1] 0.1568139 #>  #> $tss #> [1] 39 #>  #> $rss #> [1] 25.45455 #>  #> $R2 #> [1] 0.3473193 # test if the variation in the data is 0 or explained by sine function alone  ryth.test = LR_rhythmicity(tt=rot.df$rotation,yy=rot.df$sc.rotationpx,period = splits-1, method = \"LR\") splits - ryth.test$phase  #> [1] 8.535239  ## if tow tubes are ought to be compared (different insertion angles or tube diameter) tt1 = rot.df$rotation tt2 = rot.df$rotation yy1 = rot.df$sc.rotationpx # amplitude 4x times as high yy2 = rot.df$sc.rotationpx*2 + runif(length(rot.df$rotation),min = -0.1, max = 0.1 ) # + 20 WaldTest_diff_amp(tt1=tt1, yy1=yy1, tt2=tt2, yy2=yy2) #> $amp_1 #> [1] 0.8639946 #>  #> $amp_2 #> [1] 1.728164 #>  #> $amp_c #> [1] 1.027955 #>  #> $stat #> [1] 4.195124 #>  #> $pvalue #> [1] 0.05259289   ## we can also test if if the rotational root distribution corresponds to the true tube upside # rotation segments terra::plot(root.seg) +    geom_hline(yintercept = seq(0,dim(root.seg)[1],length = splits+1),              color = \"red\",size=0.05,linetype = \"solid\") +    theme_void() +    geom_text(label = 1:20,aes(x=250,                                  y= (scale((seq(0,dim(root.seg)[1],                                                 length = splits)))*                                     (sd((seq(0,dim(root.seg)[1]-(dim(root.seg)[1]/splits),                                              length =splits))))) +                                     mean((seq(0,dim(root.seg)[1],                                              length = splits)))),             color=\"black\",size=1.5) #> NULL #ggsave(\"C:/Users/jocu0013/Documents/GitHub/MinirhizotronR/figures/rotation_splicing.png\")  # based on rotation center determined previously df1 = seq(0*pi,-2*pi,-2*pi/(max(rot.df$rotation)-1)) calibrated.phase = (cos(df1+(pi*(1-center.offset))))*(6.35/2) # test the rotational root distribution vs the calibrated difftest = LRTest_diff_phase(tt1 = rot.df$rotation, tt2 =  rot.df$rotation, yy1 = calibrated.phase, yy2 = rot.df$sc.rotationpx,                   period = round(pi*6.35));difftest #> $phase_1 #> [1] 8.843225 #>  #> $phase_2 #> [1] 5.711852 #>  #> $phase_c #> [1] 5.782338 #>  #> $l0 #> [1] -71.01061 #>  #> $la #> [1] -70.9955 #>  #> $stat #> [1] 0.03021531 #>  #> $pvalue #> [1] 0.867672 # tape estimation did not reflect the center of root distribution  ## alternative polar plot rot.df<-rot.df%>%     mutate(         # Use (rotation-0.5), not just id, to center label on each item         angle=90-360*(rotation-0.5)/max(rotation)     ) %>%   mutate(exag.rootpx = rotation.rootpx**1.75)   ggplot(data= rot.df,         aes(rotation,exag.rootpx)) +    geom_bar(fill=\"indianred\",            stat = \"identity\") +      geom_text(data=rot.df,             aes(y=max(exag.rootpx)-max(exag.rootpx)*0.925,label=rotation),hjust = 0.5, size = 3,color = \"white\")+   theme_minimal()+   ylab(\"\")+xlab(\"\")+   scale_y_continuous(breaks = c(-max(rot.df$exag.rootpx)*0.1),                                        labels = \"\",                                        limits = c(      -max(rot.df$exag.rootpx)/1.25,      max(rot.df$exag.rootpx)*1    ))+  scale_x_continuous(labels = \"\",breaks = max(rot.df$exag.rootpx))+ coord_polar(start=(splits - ryth.test$phase )*1.15)"},{"path":"https://jcunow.github.io/MinirhizotronR/articles/MinirhizotronR.html","id":"turnover-estimates","dir":"Articles","previous_headings":"","what":"Turnover Estimates","title":"MinirhizotronR: Depth Resolved Analysis of Segmented Minirhizotron Scans","text":"Now time Turnover","code":"# the package offers two methods two estimate turnover.  #The function Turnover.TC() makes a comparison between two timepoints and determines production in relation to total biomass.   turn1 = Turnover.TC(skl_Oulanka2023_Session01_T067,skl_Oulanka2023_Session03_T067,method = \"kimura\");turn1 #>          sum    sum.1   sum.2   sum.3   sum.4 #> sum 1536.412 1492.178 -44.234 -0.0288 -0.0296 # PDC stands for production, decay, and constant - extracting the variables from a 'RootDetector' format turnover output turn2 = Turnover.DPC(TurnoverDPC_data, product.layer = 2, decay.layer = 1);turn2 #> # A tibble: 1 × 7 #>     tape constant production   decay newgrowth.ratio decay.ratio constant.ratio #>    <dbl>    <dbl>      <dbl>   <dbl>           <dbl>       <dbl>          <dbl> #> 1 887012   438681    2770138 3355722           0.863       0.884         0.0668 # we can also return production, decay, and constant layers instead and go apply depth stats Turnmap = terra::rast(terra::as.array(TurnoverDPC_data)[,1:2000,]) turn3 = Turnover.DPC(Turnmap, im.return = T)  turn3$production = raster::brick(turn3$production) turn3$constant = raster::brick(turn3$constant) turn3$decay = raster::brick(turn3$decay) # adapt depth map  mask = Turnmap != is.na(Turnmap) bm.turn = create.depthmap(Turnmap,mask = mask,dpi = 150) bm.turn2 =raster::brick(raster::t(bm.turn))  raster::extent(turn3$production) = raster::extent(bm.turn2)  raster::extent(turn3$decay) = raster::extent(bm.turn2)  raster::extent(turn3$constant) = raster::extent(bm.turn2)  prd = raster::zonal(turn3$production,bm.turn2,\"sum\")  dec = raster::zonal(turn3$decay,bm.turn2,\"sum\")  con = raster::zonal(turn3$constant,bm.turn2,\"sum\")    df = data.frame(prd = prd[,2],dec =  dec[,2],con =  con[,2], x = prd[,1], rootpx = root.sum[2:(length(prd[,1])+1),2])  ggplot(data=df,aes(x=x)) +     # scale_y_continuous(limits = c(0,1))+    # scale_x_continuous(limits = c(0,40))+    theme_bw()+    geom_point(aes(y = prd,color = \"prd\")) + geom_line(aes(y = prd/rootpx,color = \"prd\")) +     geom_point(aes(y = dec,color = \"dec\")) + geom_line(aes(y = dec/rootpx,color = \"dec\")) +     geom_point(aes(y = con,color = \"con\")) + geom_line(aes(y = con/rootpx,color = \"con\"))+    geom_line(aes(y = prd,color = \"prd\")) + geom_line(aes(y = prd/rootpx,color = \"prd\")) +     geom_line(aes(y = dec,color = \"dec\")) + geom_line(aes(y = dec/rootpx,color = \"dec\")) +     geom_line(aes(y = con,color = \"con\")) + geom_line(aes(y = con/rootpx,color = \"con\"))"},{"path":"https://jcunow.github.io/MinirhizotronR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Johannes Cunow. Author, maintainer.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Cunow J (2024). MinirhizotronR: Extracting Depth Resolved Metrics Minirhizotron Root Scans. R package version 1.0.0, https://jcunow.github.io/MinirhizotronR/, https://github.com/jcunow/MinirhizotronR.","code":"@Manual{,   title = {MinirhizotronR: Extracting Depth Resolved Metrics from Minirhizotron Root Scans},   author = {Johannes Cunow},   year = {2024},   note = {R package version 1.0.0, https://jcunow.github.io/MinirhizotronR/},   url = {https://github.com/jcunow/MinirhizotronR}, }"},{"path":[]},{"path":"https://jcunow.github.io/MinirhizotronR/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Extracting Depth Resolved Metrics from Minirhizotron Root Scans","text":"MinirhizotronR package designed make analysis minirhizotron root scans just little less stupid. package relies prior Image segmentation. recommend using RootDetector RootPainter. packages enables user map various root features continues depth distributions. user choice include tube insertion angle tube diameter - ignore (?). Rotational bias root prevalence can tested. Let know questions, improvements, found bugs & errors.","code":"# install the package if (!require(\"devtools\")) {   install.packages(\"devtools\") } devtools::install_github(\"jcunow/MinirhizotronR\")"},{"path":"https://jcunow.github.io/MinirhizotronR/index.html","id":"calibration","dir":"","previous_headings":"","what":"Calibration","title":"Extracting Depth Resolved Metrics from Minirhizotron Root Scans","text":"accurate results require easy gather -situ calibration tube. Traditionally, assumption tube installed perfectly, .e., exact insertion angle, insertion depth, scanner rotation position, tape overshoot tube. MinirhizotronR offers possibility approximate soil start rotation center based assumption well-taped tubes. Soil Surface Position Estimation Scanner Rotation Position, Rotation Differences Two Scans, Removal Scan Edges present one Scan .","code":"start.soil = SoilSurfE(img) RotationE(img) RotShiftDet(img1,img2) RotCensor(img,center.offset = 0.3,fixed.rotation = FALSE)  # under construction: estimating rotation by root distribution (assuming top-tube bias) LR_rhythmicity(rotation.cuts, root.px, period= number.rotation.slices)$phase * (dim(roation.cuts)[1]/number.rotations.slices) %>% round()"},{"path":"https://jcunow.github.io/MinirhizotronR/index.html","id":"the-core-function-create-a-depthmap","dir":"","previous_headings":"","what":"The core function: Create a depthmap","title":"Extracting Depth Resolved Metrics from Minirhizotron Root Scans","text":"requires: soil surface estimate, rotation center estimate, tube insertion angle, tube diameter, scan resolution Phase shifted, trimmed sine depth mapping including tube diameter tube insertion angle","code":"depthmap = create.depthmap(img,mask, tube.thicc = 7, tilt = 45, dpi = 300, start.soil = 0,center.offset = 0)"},{"path":"https://jcunow.github.io/MinirhizotronR/index.html","id":"zoning---create-analytical-units","dir":"","previous_headings":"","what":"Zoning - Create analytical units","title":"Extracting Depth Resolved Metrics from Minirhizotron Root Scans","text":"Creates discrete sub-units whole image. determines resolution depth distributions. Currently, package supports analysis within discrete depth bands. Future releases tackle response functions continuous depth. Depth-wise zoning","code":"binned.map = binning(depthmap, nn = 1,\"rounding\") root.zone = zone.fun(img, binned.map, indexD = 5, nn = 1)"},{"path":"https://jcunow.github.io/MinirhizotronR/index.html","id":"feature-extractions","dir":"","previous_headings":"","what":"Feature Extractions","title":"Extracting Depth Resolved Metrics from Minirhizotron Root Scans","text":"Parameter segmented image cut Parameter skeletonized image cut Combine Parameter RGB image cut Turnover - either two images different time points, ‘RootDetector’ root tracking output","code":"RootScapeMetrics(root.zone, metrics = c(\"lsm_c_ca\",\"lsm_c_pland\",\"lsm_c_enn_mn\")) Root.px = px.sum(root.zone) root.zone.skl = skeletonize(root.zone) RL = RootLength(root.zone.skeleton) root.thickness(Root.px, RL) Rhizosphere = Halo(root.zone, width = 5, halo.only = FALSE) soil = rgb.img[Rhizosphere == 1] < - NA Soil.texture(soil) soil.color = Tube.coloration(soil) Turnover.TC(root.zone1,root.zone2, method = \"kimura\",dpi = 300, unit = \"cm\") Turnover.DPC(root.zone.dpc, product.layer = 2, decay.layer = 1, im.return = F)"},{"path":"https://jcunow.github.io/MinirhizotronR/index.html","id":"rotational-bias","dir":"","previous_headings":"","what":"Rotational Bias","title":"Extracting Depth Resolved Metrics from Minirhizotron Root Scans","text":"Rotational zoning, Feature Extraction, Test Amplitude Difference Can used text e.g., differences top-bottom-tube bias varying insertion angle tube diameter test differences sinus fits, make use diffCircadian package https://github.com/diffCircadian/diffCircadian","code":"rotation.rootpx = data.frame(kk = 1:12,px = NA)  for(i in rotation.rootpx){ rotation.zone = zone.rotation.fun(img,k = c(i-1,i),kk = 12, mm = c(1500,5000)) rotation.rootpx$px[i,] = px.sum(rotation.zone) } fitSinCurve(rotation.rootpx$px,period = 12) LTTest_diff_amp(img1_rotation.rootpx$px,img2_rotation.rootpx$px)"},{"path":"https://jcunow.github.io/MinirhizotronR/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://jcunow.github.io/MinirhizotronR/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://jcunow.github.io/MinirhizotronR/reference/abind2.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine multi-dimensional arrays — abind2","title":"Combine multi-dimensional arrays — abind2","text":"Combine multi-dimensional arrays.  generalization cbind rbind.  Takes sequence vectors, matrices, arrays produces single array higher dimension.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/abind2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine multi-dimensional arrays — abind2","text":"","code":"abind2(   ...,   along = N,   rev.along = NULL,   new.names = NULL,   force.array = TRUE,   make.names = use.anon.names,   use.anon.names = FALSE,   use.first.dimnames = FALSE,   hier.names = FALSE,   use.dnns = FALSE )"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/abind2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine multi-dimensional arrays — abind2","text":"... number vectors, matrices, arrays, data frames. dimensions arrays must match, except one dimension (specified along=).  arguments named, name used name dimension along arrays joined.  Vectors treated dim attribute length one. Alternatively, can one (one) list argument supplied, whose components objects bound together.  Names list components treated way argument names. along (optional) dimension along bind arrays. default last dimension, .e., maximum length dim attribute supplied arrays.  along= can take non-negative value minimum length dim attribute supplied arrays plus one.  along= fractional value, value less 1, value greater N (N maximum lengths dim attribute objects bound together), new dimension created result.  cases, dimensions arguments must identical. rev.along (optional) Alternate way specify dimension along bind arrays:  along = N + 1 - rev.along.  provided mainly allow easy specification along = N + 1 (supplying                                       rev.along=0).  along rev.along supplied, supplied value along ignored. new.names (optional) new.names list, first choice dimnames attribute result.  structure dimnames attribute.  names particular dimension NULL, names dimension constructed ways. new.names character vector, used dimension names way argument names used.  Zero length (\"\") names ignored. force.array (optional) FALSE, rbind cbind called possible, .e., arguments vectors, along 1, arguments vectors matrices data frames along 1 2.  rbind cbind used, preserve data.frame classes (class r/cbind preserve).  Otherwise, abind convert objects class array.  Thus, guarantee array object returned, supply argument force.array=TRUE.  Note use rbind cbind introduces subtle changes way default dimension names constructed:  see examples . make.names (optional) TRUE, last resort dimnames along dimension deparsed versions anonymous arguments.  can result cumbersome names arguments expressions. <p>default FALSE. use.anon.names (optional) use.anon.names deprecated synonym make.names. use.first.dimnames (optional) dimension names present one argument, dimension names result take first available (default take                     last available, behavior                     rbind cbind.) hier.names (optional) TRUE, dimension names concatenated dimension composed argument name dimension names objects bound.  single list argument supplied, names components serve argument names.  hier.names can also values \"\" \"\"; determine order argument name dimension name put together (TRUE effect \"\"). use.dnns (default FALSE) Use names dimensions, e.g., names(dimnames(x)) non-empty.  multiple possible sources names dimnames, value use.first.dimnames determines result.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/abind2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine multi-dimensional arrays — abind2","text":"merged multidimensional arrays","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/abind2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Combine multi-dimensional arrays — abind2","text":"dimensions supplied vectors arrays need identical, e.g., arguments can mixture vectors matrices.  abind coerces arguments addition one dimension order make consistent arguments along=.  extra dimension added place specified along=. default action abind concatenate last dimension, rather increase number dimensions. example, result calling abind vectors longer vector (see first example ).  differs action rbind cbind return matrix called vectors.  abind can made behave like cbind vectors specifying along=2, like rbind specifying along=0. dimnames returned object pieced together dimnames arguments, names arguments.  Names dimension searched following order: new.names, argument name, dimnames (names) attribute last argument, dimnames (names) attribute second last argument, etc.  (Supplying                                          argument use.first.dimnames=TRUE changes                                          cause abind use dimnames names                                          first argument first.  default behavior                                          rbind cbind: use dimnames                                          later arguments.)  names supplied along dimension (either argument names dimnames                 arguments), names constructed anonymous arguments unless use.anon.names=FALSE.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/abind2.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Combine multi-dimensional arrays — abind2","text":"Tony Plate tplate@acm.org Richard Heiberger","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/abind2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine multi-dimensional arrays — abind2","text":"","code":"# Five different ways of binding together two matrices x <- matrix(1:12,3,4) y <- x+100 dim(abind2(x,y,along=0))     # binds on new dimension before first #> [1] 2 3 4 dim(abind2(x,y,along=1))     # binds on first dimension #> [1] 6 4 dim(abind2(x,y,along=1.5)) #> [1] 3 2 4 dim(abind2(x,y,along=2)) #> [1] 3 8 dim(abind2(x,y,along=3)) #> [1] 3 4 2 dim(abind2(x,y,rev.along=1)) # binds on last dimension #> [1] 3 8 dim(abind2(x,y,rev.along=0)) # binds on new dimension after last #> [1] 3 4 2 # Unlike cbind or rbind in that the default is to bind # along the last dimension of the inputs, which for vectors # means the result is a vector (because a vector is # treated as an array with length(dim(x))==1). abind2(x=1:4,y=5:8) #> x1 x2 x3 x4 y1 y2 y3 y4  #>  1  2  3  4  5  6  7  8  # Like cbind abind2(x=1:4,y=5:8,along=2) #>      x y #> [1,] 1 5 #> [2,] 2 6 #> [3,] 3 7 #> [4,] 4 8 abind2(x=1:4,matrix(5:20,nrow=4),along=2) #>      x            #> [1,] 1 5  9 13 17 #> [2,] 2 6 10 14 18 #> [3,] 3 7 11 15 19 #> [4,] 4 8 12 16 20 abind2(1:4,matrix(5:20,nrow=4),along=2) #>      [,1] [,2] [,3] [,4] [,5] #> [1,]    1    5    9   13   17 #> [2,]    2    6   10   14   18 #> [3,]    3    7   11   15   19 #> [4,]    4    8   12   16   20 # Like rbind abind2(x=1:4,matrix(5:20,nrow=4),along=1) #>   [,1] [,2] [,3] [,4] #> x    1    2    3    4 #>      5    9   13   17 #>      6   10   14   18 #>      7   11   15   19 #>      8   12   16   20 abind2(1:4,matrix(5:20,nrow=4),along=1) #>      [,1] [,2] [,3] [,4] #> [1,]    1    2    3    4 #> [2,]    5    9   13   17 #> [3,]    6   10   14   18 #> [4,]    7   11   15   19 #> [5,]    8   12   16   20 # Create a 3-d array out of two matrices abind2(x=matrix(1:16,nrow=4),y=matrix(17:32,nrow=4),along=3) #> , , x #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    5    9   13 #> [2,]    2    6   10   14 #> [3,]    3    7   11   15 #> [4,]    4    8   12   16 #>  #> , , y #>  #>      [,1] [,2] [,3] [,4] #> [1,]   17   21   25   29 #> [2,]   18   22   26   30 #> [3,]   19   23   27   31 #> [4,]   20   24   28   32 #>  # Use of hier.names abind2(x=cbind(a=1:3,b=4:6), y=cbind(a=7:9,b=10:12), hier.names=TRUE) #>      x.a x.b y.a y.b #> [1,]   1   4   7  10 #> [2,]   2   5   8  11 #> [3,]   3   6   9  12 # Use a list argument abind2(list(x=x, y=x), along=3) #> , , x #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    4    7   10 #> [2,]    2    5    8   11 #> [3,]    3    6    9   12 #>  #> , , y #>  #>      [,1] [,2] [,3] [,4] #> [1,]    1    4    7   10 #> [2,]    2    5    8   11 #> [3,]    3    6    9   12 #>  # Use lapply(..., get) to get the objects an <- c('x','y') names(an) <- an abind2(lapply(an, get), along=3) #> Error in FUN(X[[i]], ...): object 'x' not found"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/adaptive.Kernelsize.Directionality.html","id":null,"dir":"Reference","previous_headings":"","what":"Adaptive Kernel size — adaptive.Kernelsize.Directionality","title":"Adaptive Kernel size — adaptive.Kernelsize.Directionality","text":"Adaptive Kernel size","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/adaptive.Kernelsize.Directionality.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adaptive Kernel size — adaptive.Kernelsize.Directionality","text":"","code":"adaptive.Kernelsize.Directionality(   n = 3,   fill.value = NA,   normalized.center = -1,   diag.weighted = TRUE )"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/adaptive.Kernelsize.Directionality.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adaptive Kernel size — adaptive.Kernelsize.Directionality","text":"n amount connecting pixels. kernelsize = 2n-1 fill.value kernel fields. Default NA normalized.center value kernel center. Negative values result normalized difference diag.weighted diagonal pixels weighted 1/sqrt(2) reflect increased diagonal pixel distance.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/adaptive.Kernelsize.Directionality.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adaptive Kernel size — adaptive.Kernelsize.Directionality","text":"list containing D8 kernels degrees: 0,45,90,135,180,225,270,315","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/adaptive.Kernelsize.Directionality.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adaptive Kernel size — adaptive.Kernelsize.Directionality","text":"","code":"adaptive.Kernelsize.Directionality(n = 5) #> [[1]] #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] #>  [1,]   NA   NA   NA   NA    1   NA   NA   NA   NA #>  [2,]   NA   NA   NA   NA    1   NA   NA   NA   NA #>  [3,]   NA   NA   NA   NA    1   NA   NA   NA   NA #>  [4,]   NA   NA   NA   NA    1   NA   NA   NA   NA #>  [5,]   NA   NA   NA   NA   -1   NA   NA   NA   NA #>  [6,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [7,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [8,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [9,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  #> [[2]] #>       [,1] [,2] [,3] [,4] [,5]      [,6]      [,7]      [,8]      [,9] #>  [1,]   NA   NA   NA   NA   NA        NA        NA        NA 0.7071068 #>  [2,]   NA   NA   NA   NA   NA        NA        NA 0.7071068        NA #>  [3,]   NA   NA   NA   NA   NA        NA 0.7071068        NA        NA #>  [4,]   NA   NA   NA   NA   NA 0.7071068        NA        NA        NA #>  [5,]   NA   NA   NA   NA   -1        NA        NA        NA        NA #>  [6,]   NA   NA   NA   NA   NA        NA        NA        NA        NA #>  [7,]   NA   NA   NA   NA   NA        NA        NA        NA        NA #>  [8,]   NA   NA   NA   NA   NA        NA        NA        NA        NA #>  [9,]   NA   NA   NA   NA   NA        NA        NA        NA        NA #>  #> [[3]] #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] #>  [1,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [2,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [3,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [4,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [5,]   NA   NA   NA   NA   -1    1    1    1    1 #>  [6,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [7,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [8,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [9,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  #> [[4]] #>       [,1] [,2] [,3] [,4] [,5]      [,6]      [,7]      [,8]      [,9] #>  [1,]   NA   NA   NA   NA   NA        NA        NA        NA        NA #>  [2,]   NA   NA   NA   NA   NA        NA        NA        NA        NA #>  [3,]   NA   NA   NA   NA   NA        NA        NA        NA        NA #>  [4,]   NA   NA   NA   NA   NA        NA        NA        NA        NA #>  [5,]   NA   NA   NA   NA   -1        NA        NA        NA        NA #>  [6,]   NA   NA   NA   NA   NA 0.7071068        NA        NA        NA #>  [7,]   NA   NA   NA   NA   NA        NA 0.7071068        NA        NA #>  [8,]   NA   NA   NA   NA   NA        NA        NA 0.7071068        NA #>  [9,]   NA   NA   NA   NA   NA        NA        NA        NA 0.7071068 #>  #> [[5]] #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] #>  [1,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [2,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [3,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [4,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [5,]   NA   NA   NA   NA   -1   NA   NA   NA   NA #>  [6,]   NA   NA   NA   NA    1   NA   NA   NA   NA #>  [7,]   NA   NA   NA   NA    1   NA   NA   NA   NA #>  [8,]   NA   NA   NA   NA    1   NA   NA   NA   NA #>  [9,]   NA   NA   NA   NA    1   NA   NA   NA   NA #>  #> [[6]] #>            [,1]      [,2]      [,3]      [,4] [,5] [,6] [,7] [,8] [,9] #>  [1,]        NA        NA        NA        NA   NA   NA   NA   NA   NA #>  [2,]        NA        NA        NA        NA   NA   NA   NA   NA   NA #>  [3,]        NA        NA        NA        NA   NA   NA   NA   NA   NA #>  [4,]        NA        NA        NA        NA   NA   NA   NA   NA   NA #>  [5,]        NA        NA        NA        NA   -1   NA   NA   NA   NA #>  [6,]        NA        NA        NA 0.7071068   NA   NA   NA   NA   NA #>  [7,]        NA        NA 0.7071068        NA   NA   NA   NA   NA   NA #>  [8,]        NA 0.7071068        NA        NA   NA   NA   NA   NA   NA #>  [9,] 0.7071068        NA        NA        NA   NA   NA   NA   NA   NA #>  #> [[7]] #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] #>  [1,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [2,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [3,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [4,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [5,]    1    1    1    1   -1   NA   NA   NA   NA #>  [6,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [7,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [8,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  [9,]   NA   NA   NA   NA   NA   NA   NA   NA   NA #>  #> [[8]] #>            [,1]      [,2]      [,3]      [,4] [,5] [,6] [,7] [,8] [,9] #>  [1,] 0.7071068        NA        NA        NA   NA   NA   NA   NA   NA #>  [2,]        NA 0.7071068        NA        NA   NA   NA   NA   NA   NA #>  [3,]        NA        NA 0.7071068        NA   NA   NA   NA   NA   NA #>  [4,]        NA        NA        NA 0.7071068   NA   NA   NA   NA   NA #>  [5,]        NA        NA        NA        NA   -1   NA   NA   NA   NA #>  [6,]        NA        NA        NA        NA   NA   NA   NA   NA   NA #>  [7,]        NA        NA        NA        NA   NA   NA   NA   NA   NA #>  [8,]        NA        NA        NA        NA   NA   NA   NA   NA   NA #>  [9,]        NA        NA        NA        NA   NA   NA   NA   NA   NA #>"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/binning.html","id":null,"dir":"Reference","previous_headings":"","what":"Takes a continues depth map and bins it to a specified range — binning","title":"Takes a continues depth map and bins it to a specified range — binning","text":"Takes continues depth map bins specified range","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/binning.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Takes a continues depth map and bins it to a specified range — binning","text":"","code":"binning(depthmap, nn, round.option = \"rounding\")"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/binning.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Takes a continues depth map and bins it to a specified range — binning","text":"depthmap 1-layer raster, takes output create.depthmap() nn bin width round.option choose binning operation. Available \"rounding\", \"ceiling\", \"floor\".","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/binning.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Takes a continues depth map and bins it to a specified range — binning","text":"raster input depths bins","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/binning.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Takes a continues depth map and bins it to a specified range — binning","text":"","code":"data(seg_Oulanka2023_Session01_T067) img = terra::rast(seg_Oulanka2023_Session01_T067[[2]]) mask = seg_Oulanka2023_Session01_T067[[1]] - seg_Oulanka2023_Session01_T067[[2]] mask[mask == 255] <- NA depthmap = create.depthmap(img,mask,start.soil = 290 ) binned.map = binning(depthmap,nn = 5)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/blur.correction.html","id":null,"dir":"Reference","previous_headings":"","what":"Threshoold an image to rebinarize a blurred image (e.g., jpeg compression) — blur.correction","title":"Threshoold an image to rebinarize a blurred image (e.g., jpeg compression) — blur.correction","text":"Threshoold image rebinarize blurred image (e.g., jpeg compression)","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/blur.correction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Threshoold an image to rebinarize a blurred image (e.g., jpeg compression) — blur.correction","text":"","code":"blur.correction(img, threshold = 0.4, focus.layer = 2, mask.layer = 1)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/blur.correction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Threshoold an image to rebinarize a blurred image (e.g., jpeg compression) — blur.correction","text":"img raster threshold ratio max value assigned 1 focus.layer layer used capture blurr mask.layer preserve mask sections (e.g., tape) one layer","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/blur.correction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Threshoold an image to rebinarize a blurred image (e.g., jpeg compression) — blur.correction","text":"raster","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/blur.correction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Threshoold an image to rebinarize a blurred image (e.g., jpeg compression) — blur.correction","text":"","code":"blurred.img = terra::rast(seg_Oulanka2023_Session03_T067) img = blur.correction(blurred.img, 0.3)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/circular_mean.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a circular mean to determine average Directionality — circular_mean","title":"Calculate a circular mean to determine average Directionality — circular_mean","text":"Calculate circular mean determine average Directionality","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/circular_mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a circular mean to determine average Directionality — circular_mean","text":"","code":"circular_mean(angles, input_units = \"degrees\", output_units = \"degrees\")"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/circular_mean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a circular mean to determine average Directionality — circular_mean","text":"angles input angles input_units can either \"radians\" \"degrees\" output_units can either \"radians\" \"degrees\"","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/circular_mean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a circular mean to determine average Directionality — circular_mean","text":"average angle","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/circular_mean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate a circular mean to determine average Directionality — circular_mean","text":"","code":"circular_mean(angles = c(360,90,0), input_units = \"degrees\", output_units = \"degrees\") #> [1] 26.56505"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/create.depthmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Create A Phase-Shifted, Tilt-Amplitude Sine Depth Map — create.depthmap","title":"Create A Phase-Shifted, Tilt-Amplitude Sine Depth Map — create.depthmap","text":"Create Phase-Shifted, Tilt-Amplitude Sine Depth Map","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/create.depthmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create A Phase-Shifted, Tilt-Amplitude Sine Depth Map — create.depthmap","text":"","code":"create.depthmap(   im,   mask = NULL,   sinoid = TRUE,   tube.thicc = 7,   tilt = 45,   dpi = 300,   start.soil = 0,   center.offset = 0 )"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/create.depthmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create A Phase-Shifted, Tilt-Amplitude Sine Depth Map — create.depthmap","text":"im input image mask indicating pixels foreign objects like tape. mask : mask = im[[1]] - im[[2]] 'RootDetector' format used sinoid set sinoid = TRUE true depth used. Otherwise, tube diameter ignored. tube.thicc Diameter minirhizotron tubes tilt Minirhiztron tube insertion angle (typically 30-45 degrees) dpi Image resolution start.soil indicates soil boundary 0cm. Can retrieved 'SoilSurfE()' -situ calibration recommended center.offset rotational center. Set 0 top facing tube side perfectly middle. Set 1 upfacing tube located edges","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/create.depthmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create A Phase-Shifted, Tilt-Amplitude Sine Depth Map — create.depthmap","text":"raster image","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/create.depthmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create A Phase-Shifted, Tilt-Amplitude Sine Depth Map — create.depthmap","text":"","code":"data(seg_Oulanka2023_Session01_T067) seg_Oulanka2023_Session01_T067 = terra::rast(seg_Oulanka2023_Session01_T067) img = seg_Oulanka2023_Session01_T067[[2]] mask = seg_Oulanka2023_Session01_T067[[1]] - seg_Oulanka2023_Session01_T067[[2]] mask[mask == 255] <- NA map = create.depthmap(img,mask,start.soil = 290 )"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Directionality.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate the directional of a skeleton pixels — Directionality","title":"Estimate the directional of a skeleton pixels — Directionality","text":"Estimate directional skeleton pixels","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Directionality.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate the directional of a skeleton pixels — Directionality","text":"","code":"Directionality(im, rotate = TRUE, kernelsize = 3, leeway = 0)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Directionality.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate the directional of a skeleton pixels — Directionality","text":"im skeletonized image raster. Roots must 1, background 0. Consider input image rotation interpret output rotate image rotated 90 degrees entering? kernelsize number connecting cells leeway amount gaps allowed connecting lines","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Directionality.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate the directional of a skeleton pixels — Directionality","text":"percentage pixels given neighbor pixel position","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Directionality.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate the directional of a skeleton pixels — Directionality","text":"","code":"library(terra);library(raster)  data(\"skl_Oulanka2023_Session01_T067\") img = terra::rast(skl_Oulanka2023_Session01_T067) direction.frame = Directionality(img,kernelsize = 3)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/fisherInformation2.html","id":null,"dir":"Reference","previous_headings":"","what":"Fisher information matrix when two conditions exist — fisherInformation2","title":"Fisher information matrix when two conditions exist — fisherInformation2","text":"Obtain Fisher information matrix two conditions exist","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/fisherInformation2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fisher information matrix when two conditions exist — fisherInformation2","text":"","code":"fisherInformation2(beta, tt1, yy1, tt2, yy2, period = 24)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/fisherInformation2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fisher information matrix when two conditions exist — fisherInformation2","text":"beta parameter vector 8 following order: amp_1, phase_1, offset_1, theta_1, amp_2, phase_2, offset_2, theta_2 tt1 time vector condition 1 yy1 expression vector condition 1 tt2 time vector condition 2 yy2 expression vector condition 2 period Period since curve. Default 24.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/fisherInformation2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fisher information matrix when two conditions exist — fisherInformation2","text":"Fisher information matrix, 8*8 matrix, order input beta parameter.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/fisherInformation2.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fisher information matrix when two conditions exist — fisherInformation2","text":"Caleb","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/fisherInformation2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fisher information matrix when two conditions exist — fisherInformation2","text":"","code":"set.seed(32608) n <- 50 Period <- 24 tt1 <- runif(n,0,Period) Amp1 <- 2 Phase1 <- 6 Offset1 <- 3 yy1 <- Amp1 * sin(2*pi/Period * (tt1 + Phase1)) + Offset1 + rnorm(n,0,1) tt2 <- runif(n,0,Period) Amp2 <- 3 Phase2 <- 15 Offset2 <- 2 yy2 <- Amp2 * sin(2*pi/Period * (tt2 + Phase2)) + Offset2 + rnorm(n,0,1) beta <- c(Amp1,Phase1,Offset1,1,Amp2,Phase2,Offset2,2) fisherInformation2(beta, tt1, yy1, tt2, yy2) #>           [,1]      [,2]       [,3]       [,4]       [,5]      [,6]       [,7] #> [1,] 25.456103  1.484273 -3.6592758  1.1964346  0.0000000  0.000000   0.000000 #> [2,]  1.484273  6.564844 -3.0547070 -3.0476574  0.0000000  0.000000   0.000000 #> [3,] -3.659276 -3.054707 50.0000000 -0.2308641  0.0000000  0.000000   0.000000 #> [4,]  1.196435 -3.047657 -0.2308641 25.0000000  0.0000000  0.000000   0.000000 #> [5,]  0.000000  0.000000  0.0000000  0.0000000 46.6709485  2.940024   2.143862 #> [6,]  0.000000  0.000000  0.0000000  0.0000000  2.9400244 32.965075  -6.824443 #> [7,]  0.000000  0.000000  0.0000000  0.0000000  2.1438620 -6.824443 100.000000 #> [8,]  0.000000  0.000000  0.0000000  0.0000000 -0.1678738  7.157126  12.068982 #>            [,8] #> [1,]  0.0000000 #> [2,]  0.0000000 #> [3,]  0.0000000 #> [4,]  0.0000000 #> [5,] -0.1678738 #> [6,]  7.1571265 #> [7,] 12.0689824 #> [8,]  6.2500000"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/fitSinCurve.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit Data Based on Sine Curve — fitSinCurve","title":"Fit Data Based on Sine Curve — fitSinCurve","text":"Fit sine curve tt time, yy expression value.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/fitSinCurve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit Data Based on Sine Curve — fitSinCurve","text":"","code":"fitSinCurve(   tt,   yy,   period = 24,   parStart = list(amp = 3, phase = 0, offset = 0) )"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/fitSinCurve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit Data Based on Sine Curve — fitSinCurve","text":"tt Time vector. yy Expression vector. period Period sine curve. Default 24. parStart Initial value optimization purpose.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/fitSinCurve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit Data Based on Sine Curve — fitSinCurve","text":"list amp, phase, offset, peak, , B, SST, SSE, R2. Formula 1: \\(yy = amp * sin(2\\pi/period * (phase + tt)) + offset\\) Formula 2: \\(yy = * sin(2\\pi/period \\times tt) + B * cos(2*\\pi/period * tt) + offset\\) amp Amplitude based formula 1. phase Phase based formula 1, phase restricted within (0, period). offset Basal level (vertical shift) based formula 1 formula 2. based formula 2. B B based formula 2. tss Total sum square. rss Residual sum square, SSE/n MLE variance sigma square. R2 Pseudo R2 defined (tss - rss)/tss.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/fitSinCurve.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fit Data Based on Sine Curve — fitSinCurve","text":"Caleb","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/fitSinCurve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit Data Based on Sine Curve — fitSinCurve","text":"","code":"set.seed(32608) n <- 50 Period <- 24 tt <- runif(n,0,Period) Amp <- 2 Phase <- 6 Offset <- 3 yy <- Amp * sin(2*pi/Period * (tt + Phase)) + Offset + rnorm(n,0,1) fitSinCurve(tt, yy) #> $amp #> [1] 1.915422 #>  #> $phase #> [1] 6.536394 #>  #> $offset #> [1] 3.028329 #>  #> $peak #> [1] -0.5363939 #>  #> $A #> [1] -0.268095 #>  #> $B #> [1] 1.896567 #>  #> $tss #> [1] 125.0438 #>  #> $rss #> [1] 27.31912 #>  #> $R2 #> [1] 0.7815237 #>"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/FTest.html","id":null,"dir":"Reference","previous_headings":"","what":"F test for detecting circadian pattern — FTest","title":"F test for detecting circadian pattern — FTest","text":"Test significance circadian curve fitting using F test.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/FTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"F test for detecting circadian pattern — FTest","text":"","code":"FTest(tt, yy, period = 24)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/FTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"F test for detecting circadian pattern — FTest","text":"tt Time vector yy Expression vector period Period since curve. Default 24.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/FTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"F test for detecting circadian pattern — FTest","text":"list amp, phase, offset, peak, SST, SSE, R2. Formula 1: \\(yy = amp \\times sin(2\\pi/period \\times (phase + tt)) + offset\\) Formula 2: \\(yy = \\times sin(2\\pi/period \\times tt) + B * cos(2*pi/period * tt) + offset\\) amp Amplitude based formula 1 phase Phase based formula 1, phase restricted within (0, period) offset Basal level(vertical shift) based formula 1 formula 2 tss Total sum square rss Residual sum square, SSE/n MLE variance sigma2 R2 Pseudo R2 defined (tss - rss)/tss","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/FTest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"F test for detecting circadian pattern — FTest","text":"Caleb","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/FTest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"F test for detecting circadian pattern — FTest","text":"","code":"set.seed(32608) n <- 50 Period <- 24 tt <- runif(n,0,Period) Amp <- 2 Phase <- 6 Offset <- 3 yy <- Amp * sin(2*pi/Period * (tt + Phase)) + Offset + rnorm(n,0,1) FTest(tt, yy) #> $amp #> [1] 1.915422 #>  #> $phase #> [1] 6.536394 #>  #> $offset #> [1] 3.028329 #>  #> $rss #> [1] 27.31912 #>  #> $tss #> [1] 125.0438 #>  #> $R2 #> [1] 0.7815237 #>  #> $df1 #> [1] 2 #>  #> $df2 #> [1] 47 #>  #> $stat #> [1] 84.06316 #>  #> $pvalue #> [1] 2.992272e-16 #>"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Halo.html","id":null,"dir":"Reference","previous_headings":"","what":"Halo creates a buffer around pixel bigger than 0 — Halo","title":"Halo creates a buffer around pixel bigger than 0 — Halo","text":"Halo creates buffer around pixel bigger 0","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Halo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Halo creates a buffer around pixel bigger than 0 — Halo","text":"","code":"Halo(im, width = 2, halo.only = TRUE, kernel = \"circle\")"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Halo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Halo creates a buffer around pixel bigger than 0 — Halo","text":"im segmented raster width buffer around roots px, rhizosphere extent. Exudation diffusion distance typically 2mm (1-12mm) (Finzi et al. 2015, https://doi.org/10.1111/gcb.12816), higher values suggested. 300 dpi, 1mm = 11.8px halo.set TRUE buffer around roots returned (rhizosphere ) kernel thickening shape. Available options : \"circle\" & \"diamond\"","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Halo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Halo creates a buffer around pixel bigger than 0 — Halo","text":"SpatRaster","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Halo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Halo creates a buffer around pixel bigger than 0 — Halo","text":"","code":"library(terra)  data(seg_Oulanka2023_Session01_T067) img = terra::rast(seg_Oulanka2023_Session01_T067) Halo(im = img, width = 2, halo.only = TRUE) #> class       : SpatRaster  #> dimensions  : 1144, 4900, 3  (nrow, ncol, nlyr) #> resolution  : 0.0002040816, 0.0008741259  (x, y) #> extent      : 0, 1, 0, 1  (xmin, xmax, ymin, ymax) #> coord. ref. :   #> source(s)   : memory #> names       : lyr1, lyr2, lyr3  #> min values  :    0,    0,    0  #> max values  :    3,    3,    3"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/lines_diagonal_botleft.html","id":null,"dir":"Reference","previous_headings":"","what":"Example Image with circa right to left diagonal lines — lines_diagonal_botleft","title":"Example Image with circa right to left diagonal lines — lines_diagonal_botleft","text":"Use dataset test directionality","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/lines_diagonal_botleft.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example Image with circa right to left diagonal lines — lines_diagonal_botleft","text":"","code":"data(lines_diagonal_botleft)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/lines_diagonal_botleft.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example Image with circa right to left diagonal lines — lines_diagonal_botleft","text":"RasterBrick 191 columns x 99 rows x 4 layer","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/lines_diagonal_botleft.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example Image with circa right to left diagonal lines — lines_diagonal_botleft","text":"Images J.Cunow","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/lines_diagonal_botleft.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Example Image with circa right to left diagonal lines — lines_diagonal_botleft","text":"Johannes Cunow johannes.cunow@gmail.com","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/lines_diagonal_topleft.html","id":null,"dir":"Reference","previous_headings":"","what":"Example Image with circa left to right diagonal lines — lines_diagonal_topleft","title":"Example Image with circa left to right diagonal lines — lines_diagonal_topleft","text":"Use dataset test directionality","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/lines_diagonal_topleft.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example Image with circa left to right diagonal lines — lines_diagonal_topleft","text":"","code":"data(lines_diagonal_topleft)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/lines_diagonal_topleft.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example Image with circa left to right diagonal lines — lines_diagonal_topleft","text":"RasterBrick 194 columns x 100 rows  x 4 layer","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/lines_diagonal_topleft.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example Image with circa left to right diagonal lines — lines_diagonal_topleft","text":"Images J.Cunow","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/lines_diagonal_topleft.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Example Image with circa left to right diagonal lines — lines_diagonal_topleft","text":"Johannes Cunow johannes.cunow@gmail.com","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/lines_horizontal.html","id":null,"dir":"Reference","previous_headings":"","what":"Example Image with circa horizontal lines — lines_horizontal","title":"Example Image with circa horizontal lines — lines_horizontal","text":"Use dataset test directionality","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/lines_horizontal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example Image with circa horizontal lines — lines_horizontal","text":"","code":"data(lines_horizontal)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/lines_horizontal.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example Image with circa horizontal lines — lines_horizontal","text":"RasterBrick 184 columns x 90 rows x 4 layer","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/lines_horizontal.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example Image with circa horizontal lines — lines_horizontal","text":"Images J.Cunow","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/lines_horizontal.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Example Image with circa horizontal lines — lines_horizontal","text":"Johannes Cunow johannes.cunow@gmail.com","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/lines_vertical.html","id":null,"dir":"Reference","previous_headings":"","what":"Example Image with circa vertical lines — lines_vertical","title":"Example Image with circa vertical lines — lines_vertical","text":"Use dataset test directionality","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/lines_vertical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example Image with circa vertical lines — lines_vertical","text":"","code":"data(lines_vertical)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/lines_vertical.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example Image with circa vertical lines — lines_vertical","text":"RasterBrick 144 columns x 99 rows x 4 layer","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/lines_vertical.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example Image with circa vertical lines — lines_vertical","text":"Images J.Cunow","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/lines_vertical.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Example Image with circa vertical lines — lines_vertical","text":"Johannes Cunow johannes.cunow@gmail.com","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest.html","id":null,"dir":"Reference","previous_headings":"","what":"Finite sample/ large sample Likelihood ratio test for circadian pattern detection — LRTest","title":"Finite sample/ large sample Likelihood ratio test for circadian pattern detection — LRTest","text":"Test significance circadian curve fitting using finite sample likelihood ratio test","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finite sample/ large sample Likelihood ratio test for circadian pattern detection — LRTest","text":"","code":"LRTest(tt, yy, period = 24, FN = TRUE)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finite sample/ large sample Likelihood ratio test for circadian pattern detection — LRTest","text":"tt Time vector yy Expression vector period Period since curve. Default 24. FN Type test use, TRUE = \"FN\" (finite) FALSE = \"LS\" (large samples). Default finite sample.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finite sample/ large sample Likelihood ratio test for circadian pattern detection — LRTest","text":"list amp, phase, offset, sigma02, sigmaA2, l0, l1, df, stat, pvalue. model: \\(y= * sin(2*pi*x+B)+C\\) y 1*n vector data y estimated ^hat fitCurve B estimated B^hat fitCurve C estimated C^hat fitCurve sigma0 sigma0^hat H0 sigmaA sigmaA^hat H1 n length data y df0 df H0 df1 df H1 amp Amplitude based formula 1 phase Phase based formula 1, phase restricted within (0, period) peakTime Phase based formula 1, peakTime restricted within (0, period). phase + peakTime = period/4 offset Basal level(vertical shift) based formula 1 formula 2 sigma02 Variance estimate null (intercept ) sigmaA2 Variance estimate alternative (since curve fitting) l0 Log likelihood null (intercept ) l1 Log likelihood alternative (since curve fitting) df Degree freedom LR test stat LR statistics pvalue P-value LR test R2 Pseudo R2 defined (tss - rss)/tss","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finite sample/ large sample Likelihood ratio test for circadian pattern detection — LRTest","text":"Formula 1: \\(yy = amp \\times sin(2\\pi/period \\times (phase + tt)) + offset\\) Formula 2: \\(yy = \\times sin(2\\pi/period \\times tt) + B * cos(2*pi/period * tt) + offset\\)","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finite sample/ large sample Likelihood ratio test for circadian pattern detection — LRTest","text":"Caleb","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finite sample/ large sample Likelihood ratio test for circadian pattern detection — LRTest","text":"","code":"set.seed(32608) n <- 50 Period <- 24 tt <- runif(n,0,Period) Amp <- 2 Phase <- 6 Offset <- 3 yy <- Amp * sin(2*pi/Period * (tt + Phase)) + Offset + rnorm(n,0,1) LRTest(tt, yy) #> $amp #> [1] 1.915422 #>  #> $phase #> [1] 6.536394 #>  #> $peakTime #> [1] 23.46361 #>  #> $offset #> [1] 3.028329 #>  #> $sigma02 #> [1] 2.500877 #>  #> $sigmaA2 #> [1] 0.5463823 #>  #> $l0 #> [1] -93.86296 #>  #> $l1 #> [1] -55.83602 #>  #> $stat #> [1] 84.06316 #>  #> $pvalue #> [1] 2.992272e-16 #>  #> $R2 #> [1] 0.7815237 #>"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_amp.html","id":null,"dir":"Reference","previous_headings":"","what":"Finite sample/Large sample Likelihood ratio test for differential amplitude. — LRTest_diff_amp","title":"Finite sample/Large sample Likelihood ratio test for differential amplitude. — LRTest_diff_amp","text":"Test differential amplitude circadian curve fitting using likelihood ratio test","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_amp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finite sample/Large sample Likelihood ratio test for differential amplitude. — LRTest_diff_amp","text":"","code":"LRTest_diff_amp(tt1, yy1, tt2, yy2, period = 24, FN = TRUE)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_amp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finite sample/Large sample Likelihood ratio test for differential amplitude. — LRTest_diff_amp","text":"tt1 Time vector condition 1 yy1 Expression vector condition 1 tt2 Time vector condition 2 yy2 Expression vector condition 2 period Period since curve. Default 24. FN Type test use, TRUE = \"FN\" (finite) FALSE = \"LS\" (large samples). Default finite sample.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_amp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finite sample/Large sample Likelihood ratio test for differential amplitude. — LRTest_diff_amp","text":"list, see details . Formula 1: \\(yy = amp \\times sin(2\\pi/period \\times (phase + tt)) + offset\\) Formula 2: \\(yy = \\times sin(2\\pi/period \\times tt) + B * cos(2*pi/period * tt) + offset\\) amp_1 Amplitude estimate 1st data amp_2 Amplitude estimate 2nd data amp_c Amplitude estimate pooling data together l0 Log likelihood null (variance two groups) l1 Log likelihood alternative (different variance two groups) df Degree freedom LR test stat LR statistics pvalue P-value LR test","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_amp.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finite sample/Large sample Likelihood ratio test for differential amplitude. — LRTest_diff_amp","text":"Caleb","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_amp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finite sample/Large sample Likelihood ratio test for differential amplitude. — LRTest_diff_amp","text":"","code":"set.seed(32608) n <- 50 Period <- 24 tt1 <- runif(n,0,Period) Amp1 <- 2 Phase1 <- 6 Offset1 <- 3 yy1 <- Amp1 * sin(2*pi/Period * (tt1 + Phase1)) + Offset1 + rnorm(n,0,1) tt2 <- runif(n,0,Period) Amp2 <- 3 Phase2 <- 5 Offset2 <- 2 yy2 <- Amp2 * sin(2*pi/Period * (tt2 + Phase2)) + Offset2 + rnorm(n,0,1) LRTest_diff_amp(tt1, yy1, tt2, yy2) #> $amp_1 #> [1] 1.915422 #>  #> $amp_2 #> [1] 3.210351 #>  #> $amp_c #> [1] 2.310434 #>  #> $l0 #> [1] -45.17651 #>  #> $la #> [1] -33.37943 #>  #> $stat #> [1] 23.59417 #>  #> $pvalue #> [1] 2.638221e-06 #>"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_offset.html","id":null,"dir":"Reference","previous_headings":"","what":"Finite sample/Large sample Likelihood ratio test for differential basal level. — LRTest_diff_offset","title":"Finite sample/Large sample Likelihood ratio test for differential basal level. — LRTest_diff_offset","text":"Test differential offset circadian curve fitting using likelihood ratio test","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_offset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finite sample/Large sample Likelihood ratio test for differential basal level. — LRTest_diff_offset","text":"","code":"LRTest_diff_offset(tt1, yy1, tt2, yy2, period = 24, FN = TRUE)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_offset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finite sample/Large sample Likelihood ratio test for differential basal level. — LRTest_diff_offset","text":"tt1 Time vector condition 1 yy1 Expression vector condition 1 tt2 Time vector condition 2 yy2 Expression vector condition 2 period Period since curve. Default 24. FN Type test use, TRUE = \"FN\" (finite) FALSE = \"LS\" (large samples). Default finite sample.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_offset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finite sample/Large sample Likelihood ratio test for differential basal level. — LRTest_diff_offset","text":"list, see details . Formula 1: \\(yy = amp \\times sin(2\\pi/period \\times (phase + tt)) + offset\\) Formula 2: \\(yy = \\times sin(2\\pi/period \\times tt) + B * cos(2*pi/period * tt) + offset\\) offset_1 Basal level estimate 1st data offset_2 Basal level estimate 2nd data offset_c Basal level estimate pooling data together l0 Log likelihood null (variance two groups) l1 Log likelihood alternative (different variance two groups) df Degree freedom LR test stat LR statistics pvalue P-value LR test","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_offset.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finite sample/Large sample Likelihood ratio test for differential basal level. — LRTest_diff_offset","text":"Caleb","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_offset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finite sample/Large sample Likelihood ratio test for differential basal level. — LRTest_diff_offset","text":"","code":"set.seed(32608) n <- 50 Period <- 24 tt1 <- runif(n,0,Period) Amp1 <- 2 Phase1 <- 6 Offset1 <- 3 yy1 <- Amp1 * sin(2*pi/Period * (tt1 + Phase1)) + Offset1 + rnorm(n,0,1) tt2 <- runif(n,0,Period) Amp2 <- 3 Phase2 <- 5 Offset2 <- 2 yy2 <- Amp2 * sin(2*pi/Period * (tt2 + Phase2)) + Offset2 + rnorm(n,0,1) LRTest_diff_offset(tt1, yy1, tt2, yy2) #> $offset_1 #> [1] 3.028329 #>  #> $offset_2 #> [1] 1.725023 #>  #> $offset_c #> [1] 2.676353 #>  #> $l0 #> [1] -54.99837 #>  #> $la #> [1] -33.37943 #>  #> $stat #> [1] 43.23788 #>  #> $pvalue #> [1] 2.031872e-10 #>"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_phase.html","id":null,"dir":"Reference","previous_headings":"","what":"Finite sample/Large sample Likelihood ratio test for differential phase. — LRTest_diff_phase","title":"Finite sample/Large sample Likelihood ratio test for differential phase. — LRTest_diff_phase","text":"Test differential phase circadian curve fitting using likelihood ratio test","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_phase.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finite sample/Large sample Likelihood ratio test for differential phase. — LRTest_diff_phase","text":"","code":"LRTest_diff_phase(tt1, yy1, tt2, yy2, period = 24, FN = TRUE)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_phase.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finite sample/Large sample Likelihood ratio test for differential phase. — LRTest_diff_phase","text":"tt1 Time vector condition 1 yy1 Expression vector condition 1 tt2 Time vector condition 2 yy2 Expression vector condition 2 period Period since curve. Default 24. FN Type test use, TRUE = \"FN\" (finite) FALSE = \"LS\" (large samples). Default finite sample.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_phase.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finite sample/Large sample Likelihood ratio test for differential phase. — LRTest_diff_phase","text":"list, see details . Formula 1: \\(yy = amp \\times sin(2\\pi/period \\times (phase + tt)) + offset\\) Formula 2: \\(yy = \\times sin(2\\pi/period \\times tt) + B * cos(2*pi/period * tt) + offset\\) phase_1 Phase estimate 1st data, phase restricted (0, period) phase_2 Phase estimate 2nd data, phase restricted (0, period) phase_c Phase estimate pooling data together, phase restricted (0, period) l0 Log likelihood null (variance two groups) l1 Log likelihood alternative (different variance two groups) df Degree freedom LR test stat LR statistics pvalue P-value LR test","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_phase.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finite sample/Large sample Likelihood ratio test for differential phase. — LRTest_diff_phase","text":"Caleb","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_phase.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finite sample/Large sample Likelihood ratio test for differential phase. — LRTest_diff_phase","text":"","code":"set.seed(32608) n <- 50 Period <- 24 tt1 <- runif(n,0,Period) Amp1 <- 2 Phase1 <- 6 Offset1 <- 3 yy1 <- Amp1 * sin(2*pi/Period * (tt1 + Phase1)) + Offset1 + rnorm(n,0,1) tt2 <- runif(n,0,Period) Amp2 <- 3 Phase2 <- 5 Offset2 <- 2 yy2 <- Amp2 * sin(2*pi/Period * (tt2 + Phase2)) + Offset2 + rnorm(n,0,1) LRTest_diff_phase(tt1, yy1, tt2, yy2) #> $phase_1 #> [1] 6.536394 #>  #> $phase_2 #> [1] 5.399322 #>  #> $phase_c #> [1] 5.797734 #>  #> $l0 #> [1] -37.60327 #>  #> $la #> [1] -33.37943 #>  #> $stat #> [1] 8.447677 #>  #> $pvalue #> [1] 0.004946245 #>"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_sigma2.html","id":null,"dir":"Reference","previous_headings":"","what":"Finite sample/Large sample Likelihood ratio test for differential sigma square. — LRTest_diff_sigma2","title":"Finite sample/Large sample Likelihood ratio test for differential sigma square. — LRTest_diff_sigma2","text":"Test differential sigma2 circadian curve fitting using likelihood ratio test","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_sigma2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finite sample/Large sample Likelihood ratio test for differential sigma square. — LRTest_diff_sigma2","text":"","code":"LRTest_diff_sigma2(tt1, yy1, tt2, yy2, period = 24, FN = TRUE)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_sigma2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finite sample/Large sample Likelihood ratio test for differential sigma square. — LRTest_diff_sigma2","text":"tt1 Time vector condition 1 yy1 Expression vector condition 1 tt2 Time vector condition 2 yy2 Expression vector condition 2 period Period since curve. Default 24. FN Type test use, TRUE = \"FN\" (finite) FALSE = \"LS\" (large samples). Default finite sample.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_sigma2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finite sample/Large sample Likelihood ratio test for differential sigma square. — LRTest_diff_sigma2","text":"list, see details . Formula 1: \\(yy = amp \\times sin(2\\pi/period \\times (phase + tt)) + offset\\) Formula 2: \\(yy = \\times sin(2\\pi/period \\times tt) + B * cos(2*pi/period * tt) + offset\\) sigma2_1 Variance estimate 1st data sigma2_2 Variance estimate 2nd data sigma2_C Variance estimate pooling data together l0 Log likelihood null (variance two groups) l1 Log likelihood alternative (different variance two groups) df Degree freedom LR test stat LR statistics pvalue P-value LR test","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_sigma2.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finite sample/Large sample Likelihood ratio test for differential sigma square. — LRTest_diff_sigma2","text":"Caleb","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LRTest_diff_sigma2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finite sample/Large sample Likelihood ratio test for differential sigma square. — LRTest_diff_sigma2","text":"","code":"set.seed(32608) n <- 50 Period <- 24 tt1 <- runif(n,0,Period) Amp1 <- 2 Phase1 <- 6 Offset1 <- 3 yy1 <- Amp1 * sin(2*pi/Period * (tt1 + Phase1)) + Offset1 + rnorm(n,0,1) tt2 <- runif(n,0,Period) Amp2 <- 3 Phase2 <- 5 Offset2 <- 2 yy2 <- Amp2 * sin(2*pi/Period * (tt2 + Phase2)) + Offset2 + rnorm(n,0,1) LRTest_diff_sigma2(tt1, yy1, tt2, yy2) #> $sigma2_1 #> [1] 0.5463823 #>  #> $sigma2_2 #> [1] 0.9414007 #>  #> $sigma2_c #> [1] 0.7438915 #>  #> $l0 #> [1] -77.10085 #>  #> $la #> [1] -75.27328 #>  #> $stat #> [1] 3.65513 #>  #> $pvalue #> [1] 0.06450274 #>"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LR_rhythmicity.html","id":null,"dir":"Reference","previous_headings":"","what":"Likelihood-based Tests for Detecting Circadian Pattern. — LR_rhythmicity","title":"Likelihood-based Tests for Detecting Circadian Pattern. — LR_rhythmicity","text":"Test significance circadian curve fitting using likelihood-based tests.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LR_rhythmicity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Likelihood-based Tests for Detecting Circadian Pattern. — LR_rhythmicity","text":"","code":"LR_rhythmicity(tt, yy, period = 24, method = \"LR\", FN = TRUE)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LR_rhythmicity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Likelihood-based Tests for Detecting Circadian Pattern. — LR_rhythmicity","text":"tt Time vector yy Expression vector period Period since curve. Default 24. method Testing methods can \"Wald\" \"LR\". Default \"LR\". FN Type test use, TRUE = \"FN\" (finite) FALSE = \"LS\" (large samples). Default finite sample.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LR_rhythmicity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Likelihood-based Tests for Detecting Circadian Pattern. — LR_rhythmicity","text":"list amp, phase, offset, sigma02, sigmaA2, l0, l1, df, stat, pvalue. Formula 1: \\(yy = amp * sin(2\\pi/period * (phase + tt)) + offset\\) Formula 2: \\(yy = * sin(2\\pi/period * tt) + B * cos(2*\\pi/period * tt) + offset\\) amp Amplitude based formula 1. phase Phase based formula 1, phase restricted within (0, period). peakTime Phase based formula 1, peakTime restricted within (0, period). phase + peakTime = period/4 offset Basal level (vertical shift) based formula 1 formula 2. sigma02 Variance estimate null (intercept ). sigmaA2 Variance estimate alternative (since curve fitting). l0 Log likelihood null (intercept ). l1 Log likelihood alternative (since curve fitting). stat Test statistic. pvalue P-value test. R2 Pseudo R2 defined (tss - rss)/tss.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LR_rhythmicity.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Likelihood-based Tests for Detecting Circadian Pattern. — LR_rhythmicity","text":"Zhiguang Huo, Haocheng Ding","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/LR_rhythmicity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Likelihood-based Tests for Detecting Circadian Pattern. — LR_rhythmicity","text":"","code":"set.seed(32608) n <- 50 Period <- 24 tt <- runif(n,0,Period) Amp <- 2 Phase <- 6 Offset <- 3 yy <- Amp * sin(2*pi/Period * (tt + Phase)) + Offset + rnorm(n,0,1) LR_rhythmicity(tt, yy, period=24, method=\"LR\", FN=TRUE) #> $amp #> [1] 1.915422 #>  #> $phase #> [1] 6.536394 #>  #> $peakTime #> [1] 23.46361 #>  #> $offset #> [1] 3.028329 #>  #> $sigma02 #> [1] 2.500877 #>  #> $sigmaA2 #> [1] 0.5463823 #>  #> $l0 #> [1] -93.86296 #>  #> $l1 #> [1] -55.83602 #>  #> $stat #> [1] 84.06316 #>  #> $pvalue #> [1] 2.992272e-16 #>  #> $R2 #> [1] 0.7815237 #>"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/MinirhizotronR-package.html","id":null,"dir":"Reference","previous_headings":"","what":"MinirhizotronR: Extracting Depth Resolved Metrics from Minirhizotron Root Scans — MinirhizotronR-package","title":"MinirhizotronR: Extracting Depth Resolved Metrics from Minirhizotron Root Scans — MinirhizotronR-package","text":"MinirhizotronR, analyzing root scans minirhizotron tubes becomes piece cake. enables user extract various root metrics relate depth distribution, assess rotational biases. relies outside handling Image Segmentation.","code":""},{"path":[]},{"path":"https://jcunow.github.io/MinirhizotronR/reference/MinirhizotronR-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"MinirhizotronR: Extracting Depth Resolved Metrics from Minirhizotron Root Scans — MinirhizotronR-package","text":"Maintainer: Johannes Cunow johannes.cunow@gmail.com (ORCID)","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/px.sum.html","id":null,"dir":"Reference","previous_headings":"","what":"counts all pixels in a segmented image — px.sum","title":"counts all pixels in a segmented image — px.sum","text":"counts pixels segmented image","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/px.sum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"counts all pixels in a segmented image — px.sum","text":"","code":"px.sum(root.zone)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/px.sum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"counts all pixels in a segmented image — px.sum","text":"root.zone one layer raster","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/px.sum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"counts all pixels in a segmented image — px.sum","text":"numeric value","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/px.sum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"counts all pixels in a segmented image — px.sum","text":"","code":"data(seg_Oulanka2023_Session01_T067) img = terra::rast(seg_Oulanka2023_Session01_T067[[2]]) rootpixel  = px.sum(img)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/rgb2gray.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts RGB to Grayscale — rgb2gray","title":"Converts RGB to Grayscale — rgb2gray","text":"Converts RGB Grayscale","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/rgb2gray.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts RGB to Grayscale — rgb2gray","text":"","code":"rgb2gray(img, r = 0.21, g = 0.72, b = 0.07)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/rgb2gray.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts RGB to Grayscale — rgb2gray","text":"img rgb raster r weight red color g weight green color b weight blue color","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/rgb2gray.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts RGB to Grayscale — rgb2gray","text":"single layer gray scale raster","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/rgb2gray.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converts RGB to Grayscale — rgb2gray","text":"","code":"data(seg_Oulanka2023_Session01_T067) img = seg_Oulanka2023_Session01_T067 gray.raster = rgb2gray(img)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/rgb_Oulanka2023_Session03_T067.html","id":null,"dir":"Reference","previous_headings":"","what":"An original Minirhizotron Root Scan from Timepoint 2 — rgb_Oulanka2023_Session03_T067","title":"An original Minirhizotron Root Scan from Timepoint 2 — rgb_Oulanka2023_Session03_T067","text":"blended image multiple scans stitched together. scan originates sedge fen northern Finland late October. Columns correspond tube length rows tube rotation","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/rgb_Oulanka2023_Session03_T067.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"An original Minirhizotron Root Scan from Timepoint 2 — rgb_Oulanka2023_Session03_T067","text":"","code":"data(rgb_Oulanka2023_Session03_T067)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/rgb_Oulanka2023_Session03_T067.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"An original Minirhizotron Root Scan from Timepoint 2 — rgb_Oulanka2023_Session03_T067","text":"RasterBrick 4900 columns x 1161 rows x 3 layer","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/rgb_Oulanka2023_Session03_T067.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"An original Minirhizotron Root Scan from Timepoint 2 — rgb_Oulanka2023_Session03_T067","text":"Images J.Cunow","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/rgb_Oulanka2023_Session03_T067.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"An original Minirhizotron Root Scan from Timepoint 2 — rgb_Oulanka2023_Session03_T067","text":"Johannes Cunow johannes.cunow@gmail.com","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/root.accumulation.html","id":null,"dir":"Reference","previous_headings":"","what":"Root accumulation Curve — root.accumulation","title":"Root accumulation Curve — root.accumulation","text":"Root accumulation Curve","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/root.accumulation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Root accumulation Curve — root.accumulation","text":"","code":"root.accumulation(x, group, depth, variable, stdrz = \"counts\")"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/root.accumulation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Root accumulation Curve — root.accumulation","text":"group specify grouping variable e.g., Plot. Can multiple groups vector. depth specify column name includes depth values variable accumulating values data data.frame must include group,depth, variable columns strdz choose \"counts\" return accumulative amount, \"additive\" returns added accumulative share 0-1, \"relative\", accumulative values sum 1","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/root.accumulation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Root accumulation Curve — root.accumulation","text":"data.frame one added column \"cs\" containing accumulated values","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/root.accumulation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Root accumulation Curve — root.accumulation","text":"","code":"df = data.frame(depth = c(seq(0,80,20),seq(0,80,20)),                Plot = c(rep(\"a\",5),rep(\"b\",5)), rootpx = c(5,50,20,15,5,10,40,30,10,5) ) accum_root = root.accumulation(df,group = \"Plot\", depth = \"depth\", variable = \"rootpx\")"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/root.thickness.html","id":null,"dir":"Reference","previous_headings":"","what":"Approximate average Root Thickness — root.thickness","title":"Approximate average Root Thickness — root.thickness","text":"Approximate average Root Thickness","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/root.thickness.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Approximate average Root Thickness — root.thickness","text":"","code":"root.thickness(kimuralength, rootpx, dpi = 300)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/root.thickness.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Approximate average Root Thickness — root.thickness","text":"kimuralength length roots image section, input unit cm. rootpx amount rootpx image section dpi image resolution","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/root.thickness.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Approximate average Root Thickness — root.thickness","text":"value units cm","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/root.thickness.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Approximate average Root Thickness — root.thickness","text":"","code":"root.ticc = root.thickness(kimuralength = 300,rootpx = 9500, dpi = 300)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RootLength.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Kimura Root Length — RootLength","title":"Estimate Kimura Root Length — RootLength","text":"Estimate Kimura Root Length","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RootLength.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Kimura Root Length — RootLength","text":"","code":"RootLength(im, unit = \"cm\", dpi = 300)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RootLength.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Kimura Root Length — RootLength","text":"im skeletonized root image raster unit output unit dpi image resolution","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RootLength.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Kimura Root Length — RootLength","text":"root length","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RootLength.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Kimura Root Length — RootLength","text":"","code":"data(skl_Oulanka2023_Session01_T067) img = terra::rast(skl_Oulanka2023_Session01_T067[[2]]) RL = RootLength(im = img,unit = \"cm\", dpi = 300)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RootScapeMetrics.html","id":null,"dir":"Reference","previous_headings":"","what":"RootScapeMetric relies on Landscapemetrics to extract 'Root Scape' Features akin to landscape analysis. — RootScapeMetrics","title":"RootScapeMetric relies on Landscapemetrics to extract 'Root Scape' Features akin to landscape analysis. — RootScapeMetrics","text":"RootScapeMetric relies Landscapemetrics extract 'Root Scape' Features akin landscape analysis.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RootScapeMetrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RootScapeMetric relies on Landscapemetrics to extract 'Root Scape' Features akin to landscape analysis. — RootScapeMetrics","text":"","code":"RootScapeMetrics(   im,   indexD = NA,   metrics = c(\"lsm_c_ca\", \"lsm_l_ent\", \"lsm_c_pd\", \"lsm_c_np\", \"lsm_c_pland\",     \"lsm_c_area_mn\", \"lsm_c_area_cv\", \"lsm_c_enn_mn\", \"lsm_c_enn_cv\") )"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RootScapeMetrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"RootScapeMetric relies on Landscapemetrics to extract 'Root Scape' Features akin to landscape analysis. — RootScapeMetrics","text":"im segmented raster  (values = 0,1). Consider whether skeletonized raster appropriate. indexD please specify depth. affect output column = \"depth\". Useful used loop. metrics ,metrics calculated available ones 'landscapemetrics::calculate_lsm()'.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RootScapeMetrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"RootScapeMetric relies on Landscapemetrics to extract 'Root Scape' Features akin to landscape analysis. — RootScapeMetrics","text":"bunch metric values","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RootScapeMetrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"RootScapeMetric relies on Landscapemetrics to extract 'Root Scape' Features akin to landscape analysis. — RootScapeMetrics","text":"","code":"data(seg_Oulanka2023_Session01_T067) img = terra::rast(seg_Oulanka2023_Session01_T067)[[2]] RootScapeObject  = RootScapeMetrics(img,indexD = 80, metrics = c(\"lsm_c_ca\")) #> Warning: Please use 'check_landscape()' to ensure the input data is valid."},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RotationE.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimates Rotation from Tape Coverage. Assumes that more tape is present on the tube upside. — RotationE","title":"Estimates Rotation from Tape Coverage. Assumes that more tape is present on the tube upside. — RotationE","text":"Estimates Rotation Tape Coverage. Assumes tape present tube upside.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RotationE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimates Rotation from Tape Coverage. Assumes that more tape is present on the tube upside. — RotationE","text":"","code":"RotationE(   img,   tape.brightness = 0.66,   extra.rows = 100,   search.area = 0.45,   tape.quantile = 0.98,   nclasses = 3 )"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RotationE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimates Rotation from Tape Coverage. Assumes that more tape is present on the tube upside. — RotationE","text":"img takes raster, file name, array input. tape.brightness used clustering. Silver Dukt tape appears bright e.g., > 0.66. extra.rows case tape present. Best leave unchanged - extra.rows recommended subtracted output anyway. search.area portion image perform tape search . Potential speed increase. tape.quantile aligns extra.rows brightness tape ensure cluster class. default uses Silver Tape reference. nclasses number classes group pixels unsupervised Clustering RStoolbox package. Leave default unless weird results displayed.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RotationE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimates Rotation from Tape Coverage. Assumes that more tape is present on the tube upside. — RotationE","text":"numeric value corresponding center extruding tape","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RotationE.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimates Rotation from Tape Coverage. Assumes that more tape is present on the tube upside. — RotationE","text":"","code":"img = terra::rast(seg_Oulanka2023_Session01_T067) r0 = RotationE(img)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RotCensor.html","id":null,"dir":"Reference","previous_headings":"","what":"Rotation Censor — RotCensor","title":"Rotation Censor — RotCensor","text":"Rotation Censor","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RotCensor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rotation Censor — RotCensor","text":"","code":"RotCensor(   img,   center.offset = 0,   cut.buffer = 0.02,   fixed.rotation = TRUE,   fixed.width = 1000 )"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RotCensor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rotation Censor — RotCensor","text":"img image censored center.offset Rotational shift rows. Can retrieved 'RotShiftDet()', reference image 0 offset cut.buffer ratio image dimensions cut fixed.rotation=FALSE fixed.rotation specifies whether censoring applied fixed output dimensions (=TRUE) proportional input dimensions (=FALSE) fixed.width fixed.rotation TRUE, fixed.width specifies final amount rows centered center.offset","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RotCensor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rotation Censor — RotCensor","text":"raster","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RotCensor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rotation Censor — RotCensor","text":"","code":"data(seg_Oulanka2023_Session01_T067) img = terra::rast(seg_Oulanka2023_Session01_T067) censored.raster = RotCensor(img,center.offset = 120, cut.buffer = 0.02)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RotShiftDet.html","id":null,"dir":"Reference","previous_headings":"","what":"Rotation Correlation — RotShiftDet","title":"Rotation Correlation — RotShiftDet","text":"Rotation Correlation","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RotShiftDet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rotation Correlation — RotShiftDet","text":"","code":"RotShiftDet(img1, img2, cor.type = \"phase\")"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RotShiftDet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rotation Correlation — RotShiftDet","text":"img1 Reference Image 3 rgb channel img2 Subsequent Image 3 rgb channel cor.type Two correlation types available: \"ccf\" cross correlation, \"phase\" phase correlation frequency domain. See ??imagefx","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RotShiftDet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rotation Correlation — RotShiftDet","text":"numeric value corresponding rotation rows. Ensure correct image rotation .e., rows == rotation","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/RotShiftDet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rotation Correlation — RotShiftDet","text":"","code":"img1 = seg_Oulanka2023_Session01_T067 img2 = seg_Oulanka2023_Session03_T067 y.lag = RotShiftDet(img1,img2,\"phase\") #> [1] \"Subsequent images differ in size. If the difference is large, reconsider if this operation is valid! Difference is -17 px & -17 px.\""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/seg_Oulanka2023_Session01_T067.html","id":null,"dir":"Reference","previous_headings":"","what":"A Minirhizotron Root Scan after Segmentation from Timepoint 1 — seg_Oulanka2023_Session01_T067","title":"A Minirhizotron Root Scan after Segmentation from Timepoint 1 — seg_Oulanka2023_Session01_T067","text":"image derived rgb root scan using \"RootDetector\" segment. Roots represented = 1, Background = 0. first layer also shows foreign objects tape = 1. scan originates sedge fen northern Finland early June. Columns correspond tube length rows tube rotation","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/seg_Oulanka2023_Session01_T067.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A Minirhizotron Root Scan after Segmentation from Timepoint 1 — seg_Oulanka2023_Session01_T067","text":"","code":"data(seg_Oulanka2023_Session01_T067)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/seg_Oulanka2023_Session01_T067.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A Minirhizotron Root Scan after Segmentation from Timepoint 1 — seg_Oulanka2023_Session01_T067","text":"RasterBrick 4900 columns x 1144 rows x 3 layer","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/seg_Oulanka2023_Session01_T067.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"A Minirhizotron Root Scan after Segmentation from Timepoint 1 — seg_Oulanka2023_Session01_T067","text":"Images J.Cunow","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/seg_Oulanka2023_Session01_T067.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"A Minirhizotron Root Scan after Segmentation from Timepoint 1 — seg_Oulanka2023_Session01_T067","text":"Johannes Cunow johannes.cunow@gmail.com","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/seg_Oulanka2023_Session03_T067.html","id":null,"dir":"Reference","previous_headings":"","what":"A Minirhizotron Root Scan after Segmentation from Timepoint 2 — seg_Oulanka2023_Session03_T067","title":"A Minirhizotron Root Scan after Segmentation from Timepoint 2 — seg_Oulanka2023_Session03_T067","text":"image derived rgb root scan using \"RootDetector\" segment. Roots represented = 1, Background = 0. first layer also shows foreign objects tape = 1. scan originates sedge fen northern Finland early June. Columns correspond tube length rows tube rotation","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/seg_Oulanka2023_Session03_T067.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A Minirhizotron Root Scan after Segmentation from Timepoint 2 — seg_Oulanka2023_Session03_T067","text":"","code":"data(seg_Oulanka2023_Session03_T067)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/seg_Oulanka2023_Session03_T067.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A Minirhizotron Root Scan after Segmentation from Timepoint 2 — seg_Oulanka2023_Session03_T067","text":"RasterBrick 4900 columns x 1161 rows x 3 layer","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/seg_Oulanka2023_Session03_T067.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"A Minirhizotron Root Scan after Segmentation from Timepoint 2 — seg_Oulanka2023_Session03_T067","text":"Images J.Cunow","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/seg_Oulanka2023_Session03_T067.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"A Minirhizotron Root Scan after Segmentation from Timepoint 2 — seg_Oulanka2023_Session03_T067","text":"Johannes Cunow johannes.cunow@gmail.com","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/skeletonize.html","id":null,"dir":"Reference","previous_headings":"","what":"Skeletonize a segmented image — skeletonize","title":"Skeletonize a segmented image — skeletonize","text":"Skeletonize segmented image","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/skeletonize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Skeletonize a segmented image — skeletonize","text":"","code":"skeletonize(img, itr = 2, kernel = \"Skeleton:3\")"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/skeletonize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Skeletonize a segmented image — skeletonize","text":"img can : path, array, raster, magick object itr iterations thinning. see magick::image_morphology kernel kernel used image operation. operations skeletonizing possible.max(se)","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/skeletonize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Skeletonize a segmented image — skeletonize","text":"image magick object","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/skeletonize.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Skeletonize a segmented image — skeletonize","text":"Uses magick::image_morphology eases image input format","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/skeletonize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Skeletonize a segmented image — skeletonize","text":"","code":"data(skl_Oulanka2023_Session01_T067) img.skeleton = skeletonize(skl_Oulanka2023_Session01_T067,itr = 2)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/skl_Oulanka2023_Session01_T067.html","id":null,"dir":"Reference","previous_headings":"","what":"A Minirhizotron Root Scan after Segmentation and Skeletonization from Timepoint 1 — skl_Oulanka2023_Session01_T067","title":"A Minirhizotron Root Scan after Segmentation and Skeletonization from Timepoint 1 — skl_Oulanka2023_Session01_T067","text":"image derived rgb root scan using \"RootDetector\" segment skeletonize. Roots represented = 1, Background = 0. first layer also shows foreign objects tape = 1. scan originates sedge fen northern Finland early June. Columns correspond tube length rows tube rotation","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/skl_Oulanka2023_Session01_T067.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A Minirhizotron Root Scan after Segmentation and Skeletonization from Timepoint 1 — skl_Oulanka2023_Session01_T067","text":"","code":"data(skl_Oulanka2023_Session01_T067)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/skl_Oulanka2023_Session01_T067.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A Minirhizotron Root Scan after Segmentation and Skeletonization from Timepoint 1 — skl_Oulanka2023_Session01_T067","text":"RasterBrick 4900 columns x 1144 rows x 3 layer","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/skl_Oulanka2023_Session01_T067.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"A Minirhizotron Root Scan after Segmentation and Skeletonization from Timepoint 1 — skl_Oulanka2023_Session01_T067","text":"Images J.Cunow","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/skl_Oulanka2023_Session01_T067.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"A Minirhizotron Root Scan after Segmentation and Skeletonization from Timepoint 1 — skl_Oulanka2023_Session01_T067","text":"Johannes Cunow johannes.cunow@gmail.com","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/skl_Oulanka2023_Session03_T067.html","id":null,"dir":"Reference","previous_headings":"","what":"A Minirhizotron Root Scan after Segmentation and Skeletonization from Timepoint 2 — skl_Oulanka2023_Session03_T067","title":"A Minirhizotron Root Scan after Segmentation and Skeletonization from Timepoint 2 — skl_Oulanka2023_Session03_T067","text":"image derived rgb root scan using \"RootDetector\" segment skeletonize. Roots represented = 1, Background = 0. first layer also shows foreign objects tape = 1. scan originates sedge fen northern Finland early June. Columns correspond tube length rows tube rotation","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/skl_Oulanka2023_Session03_T067.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A Minirhizotron Root Scan after Segmentation and Skeletonization from Timepoint 2 — skl_Oulanka2023_Session03_T067","text":"","code":"data(skl_Oulanka2023_Session03_T067)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/skl_Oulanka2023_Session03_T067.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A Minirhizotron Root Scan after Segmentation and Skeletonization from Timepoint 2 — skl_Oulanka2023_Session03_T067","text":"RasterBrick 4900 columns x 1161 rows x 3 layer","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/skl_Oulanka2023_Session03_T067.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"A Minirhizotron Root Scan after Segmentation and Skeletonization from Timepoint 2 — skl_Oulanka2023_Session03_T067","text":"Images J.Cunow","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/skl_Oulanka2023_Session03_T067.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"A Minirhizotron Root Scan after Segmentation and Skeletonization from Timepoint 2 — skl_Oulanka2023_Session03_T067","text":"Johannes Cunow johannes.cunow@gmail.com","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/SoilSurfE.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate the position of the soil surface by tape presence — SoilSurfE","title":"Estimate the position of the soil surface by tape presence — SoilSurfE","text":"Estimate position soil surface tape presence","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/SoilSurfE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate the position of the soil surface by tape presence — SoilSurfE","text":"","code":"SoilSurfE(   img,   search.area = 0.45,   tape.tresh = 0.33,   dpi = 300,   nclasses = 3,   inverse = FALSE,   tape.overlap = 0.5,   tape.brightness = 0.6,   extra.rows = 100,   tape.quantile = 0.98 )"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/SoilSurfE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate the position of the soil surface by tape presence — SoilSurfE","text":"img raster,filename, array input search.area ratio image used look tape cover. Speeds computation. tape.tresh ratio much tube rotation needs covered tape dpi image resolution nclasses number clusters discern tape, roots, background. 3 rgb images. 2 can appropriate segmented 0-1 images. tape.overlap assumes safety margin tape. soil surface shifted amount cm tape.brightness used clustering. Tape appears bright e.g., 0.66 extra.rows case tape present. Best leave unchanged - extra.rows recommended subtracted output anyway. tape.quantile aligns extra.rows brightness tape. default uses Silver Tape reference.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/SoilSurfE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate the position of the soil surface by tape presence — SoilSurfE","text":"data.frame tape end soil surface estimation rows","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/SoilSurfE.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate the position of the soil surface by tape presence — SoilSurfE","text":"","code":"img = seg_Oulanka2023_Session01_T067 Soil0Estimates = SoilSurfE(img)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/tail_weighted_js_divergence.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the tail-weighted Jensen-Shannon divergence — tail_weighted_js_divergence","title":"Compute the tail-weighted Jensen-Shannon divergence — tail_weighted_js_divergence","text":"Compute tail-weighted Jensen-Shannon divergence","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/tail_weighted_js_divergence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the tail-weighted Jensen-Shannon divergence — tail_weighted_js_divergence","text":"","code":"tail_weighted_js_divergence(   P,   Q,   parameter = list(lambda = 0.2, x0 = 30),   method = \"constant\",   inverse = FALSE,   alignPQ = TRUE,   index = 1:min(c(length(Q), length(P))),   index.spacing = \"equal\" )"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/tail_weighted_js_divergence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the tail-weighted Jensen-Shannon divergence — tail_weighted_js_divergence","text":"P probability vector 2 Q probability vector 1 parameter list lambda -> shape parameter (0 = constant weighting) & x0 -> curve offset (= inflexion point ) method weighting function along index. Available options : c(\"constant\", \"asymptotic\", \"linear, \"exponential\", \"sigmoid\", \"gompertz\",\"step\") inverse changes right tail left tail TRUE index positive numeric vector containing probability spacing e.g., depth index.spacing whether index intervals equally distant .e., c(1,2,3,4....n), \"equal\" index c(1,n)","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/tail_weighted_js_divergence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the tail-weighted Jensen-Shannon divergence — tail_weighted_js_divergence","text":"Jensen-Shannon Divergence - symmetric version KL","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/tail_weighted_js_divergence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the tail-weighted Jensen-Shannon divergence — tail_weighted_js_divergence","text":"","code":"P <- c(0.025,0.05,0.1,0.15, 0.2, 0.3,0.4, 0.5,0.3,0.1)  # Distribution P Q <- c(0.025,0.05,0.1,0.15, 0.2, 0.3,0.4, 0.5,0.3,0.1)**6  # Distribution Q  # Ensure the distributions are valid (non-negative and sum to 1) P <- P / sum(P) Q <- Q / sum(Q)  tail_weighted_js_divergence(P,Q,parameter = list(lambda = 0.2,x0=30)) #> [1] 0.197"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/tail_weighted_kl_divergence.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate tail-weighted KL divergence for discrete distributions — tail_weighted_kl_divergence","title":"Calculate tail-weighted KL divergence for discrete distributions — tail_weighted_kl_divergence","text":"Calculate tail-weighted KL divergence discrete distributions","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/tail_weighted_kl_divergence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate tail-weighted KL divergence for discrete distributions — tail_weighted_kl_divergence","text":"","code":"tail_weighted_kl_divergence(   P,   Q,   index = 1:min(c(length(Q), length(P))),   index.spacing = \"equal\",   parameter = list(lambda = 0.2, x0 = 30),   inverse = FALSE,   method = \"step\",   alignPQ = TRUE )"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/tail_weighted_kl_divergence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate tail-weighted KL divergence for discrete distributions — tail_weighted_kl_divergence","text":"P probability vector 2 Q probability vector 1 index positive numeric vector containing probability spacing e.g., depth index.spacing whether index intervals equally distant .e., c(1,2,3,4....n), \"equal\" index c(1,n) parameter list lambda -> shape parameter (0 = constant weighting) & x0 -> curve offset (= inflexion point ) inverse changes right tail left tail TRUE method weighting function along index. Available options : c(\"constant\", \"asymptotic\", \"linear, \"exponential\", \"sigmoid\", \"gompertz\",\"step\") alignPQ TRUE, index end values cut case unequal length P & Q length P & Q equal","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/tail_weighted_kl_divergence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate tail-weighted KL divergence for discrete distributions — tail_weighted_kl_divergence","text":"KL divergence, symmetrical - changing input order change result","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/tail_weighted_wasserstein_distance.html","id":null,"dir":"Reference","previous_headings":"","what":"A tailweighted Version of 1 dimensional Wasserstein distance betwwen two probability vectors — tail_weighted_wasserstein_distance","title":"A tailweighted Version of 1 dimensional Wasserstein distance betwwen two probability vectors — tail_weighted_wasserstein_distance","text":"tailweighted Version 1 dimensional Wasserstein distance betwwen two probability vectors","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/tail_weighted_wasserstein_distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A tailweighted Version of 1 dimensional Wasserstein distance betwwen two probability vectors — tail_weighted_wasserstein_distance","text":"","code":"tail_weighted_wasserstein_distance(   Q,   P,   inverse = F,   parameter = list(lambda = 0.2, x0 = 10),   method = \"step\",   baseline.weight = 0,   index = 1:min(c(length(Q), length(P))),   index.spacing = \"equal\" )"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/tail_weighted_wasserstein_distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A tailweighted Version of 1 dimensional Wasserstein distance betwwen two probability vectors — tail_weighted_wasserstein_distance","text":"Q probability vector 1 P probability vector 2 inverse changes right tail left tail TRUE parameter list lambda -> shape parameter (0 = constant weighting) & x0 -> curve offset (= inflexion point ) method weighting function along index. Available options : c(\"constant\", \"linear, \"exponential\", \"sigmoid\", \"gompertz\")","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/tail_weighted_wasserstein_distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A tailweighted Version of 1 dimensional Wasserstein distance betwwen two probability vectors — tail_weighted_wasserstein_distance","text":"wasserstein metric","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/tail_weighted_wasserstein_distance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A tailweighted Version of 1 dimensional Wasserstein distance betwwen two probability vectors — tail_weighted_wasserstein_distance","text":"","code":"P <- c(0.025,0.05,0.1,0.15, 0.2, 0.3,0.4, 0.5,0.3,0.1)  # Distribution P Q <- c(0.025,0.05,0.1,0.15, 0.2, 0.3,0.4, 0.5,0.3,0.1)**6  # Distribution Q  # Ensure the distributions are valid (non-negative and sum to 1) P <- P / sum(P) Q <- Q / sum(Q)  tail_weighted_wasserstein_distance(P,Q,inverse=F,method=\"constant\",parameter = list(lambda = 0.2,x0=3)) #> [1] 0.1008476"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/tail_weight_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Tail weight function (e.g., exponential weight for tail emphasis) — tail_weight_function","title":"Tail weight function (e.g., exponential weight for tail emphasis) — tail_weight_function","text":"Tail weight function (e.g., exponential weight tail emphasis)","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/tail_weight_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tail weight function (e.g., exponential weight for tail emphasis) — tail_weight_function","text":"","code":"tail_weight_function(   index = NULL,   parameter = list(lambda = 0.2, x0 = 5),   index.spacing = \"equal\",   method = \"sigmoid\",   baseline.weight = 0,   inverse = FALSE )"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/tail_weight_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tail weight function (e.g., exponential weight for tail emphasis) — tail_weight_function","text":"index positive numeric vector containing probability spacing e.g., depth parameter list lambda -> shape parameter (0 = constant weighting) & x0 -> curve offset (= inflexion point? ) index.spacing whether index intervals equally distant .e., c(1,2,3,4....n), \"equal\" index c(1,n) method weighting function along index. Available options : c(\"constant\", \"asymptotic\", \"linear, \"exponential\", \"sigmoid\", \"gompertz\",\"step\") baseline.weight minimal weight 0-1 inverse changes right tail left tail TRUE","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/tail_weight_function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tail weight function (e.g., exponential weight for tail emphasis) — tail_weight_function","text":"weights 0-1 along index","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/texture.html","id":null,"dir":"Reference","previous_headings":"","what":"Texture corresponds to glmc::glmc() — texture","title":"Texture corresponds to glmc::glmc() — texture","text":"Texture corresponds glmc::glmc()","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/texture.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Texture corresponds to glmc::glmc() — texture","text":"","code":"texture(   img.color,   grays = 7,   window = c(9, 9),   metrics = c(\"variance\", \"second_moment\") )"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/texture.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Texture corresponds to glmc::glmc() — texture","text":"img.color image three color channels. converted gray scale. raster format required. grays number gray shades. Documentation lacking, see: ?glmc::glmc() window convolution window size e.g., c(3,3) metrics texture metrics based illumination differences. see:: ?glmc::glmc() available methods","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/texture.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Texture corresponds to glmc::glmc() — texture","text":"raster layer correspond metric","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/texture.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Texture corresponds to glmc::glmc() — texture","text":"","code":"data(rgb_Oulanka2023_Session03_T067) img = rgb_Oulanka2023_Session03_T067 texture(img, 7, c(9,9), metrics = \"second_moment\") #> Warning: [rast] unknown extent #> Warning: [rast] unknown extent #> Warning: [rast] unknown extent #> Warning: [rast] unknown extent"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Tube.coloration.html","id":null,"dir":"Reference","previous_headings":"","what":"Coloration of the image — Tube.coloration","title":"Coloration of the image — Tube.coloration","text":"Coloration image","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Tube.coloration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coloration of the image — Tube.coloration","text":"","code":"Tube.coloration(img, r = 0.2126, g = 0.7152, b = 0.0722)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Tube.coloration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coloration of the image — Tube.coloration","text":"img raster 3 color bands r weight first channel - typically red g weight second channel - typically green b weight third channel - typically blue","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Tube.coloration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coloration of the image — Tube.coloration","text":"vector chromatic coordinates,luminosity, brightness, luminosity, color values, saturation","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Tube.coloration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coloration of the image — Tube.coloration","text":"","code":"data(rgb_Oulanka2023_Session03_T067) img = terra::rast(rgb_Oulanka2023_Session03_T067) #> Warning: [rast] unknown extent colorvector = Tube.coloration(img = img)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Turnover.DPC.html","id":null,"dir":"Reference","previous_headings":"","what":"Extracts Root Decay, New Root Production, and No-Change Roots. Relies on 'RootDetector' — Turnover.DPC","title":"Extracts Root Decay, New Root Production, and No-Change Roots. Relies on 'RootDetector' — Turnover.DPC","text":"Extracts Root Decay, New Root Production, -Change Roots. Relies 'RootDetector'","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Turnover.DPC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extracts Root Decay, New Root Production, and No-Change Roots. Relies on 'RootDetector' — Turnover.DPC","text":"","code":"Turnover.DPC(   img,   product.layer = 2,   decay.layer = 1,   blur.capture = 0.95,   im.return = FALSE,   include.virtualroots = FALSE )"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Turnover.DPC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extracts Root Decay, New Root Production, and No-Change Roots. Relies on 'RootDetector' — Turnover.DPC","text":"img image 'RootDetector' format - one layer production, one layer decay, one layer stagnation product.layer layer indicating production decay.layer layer indicating decay & tape blur.capture pixel included :  value >= max value * blur.capture. Ensures attenuated pixels (result blurring resizing) also included im.return return images instead values? include.virtualroots roots present point one two time steps considered? Consider decay production ratio, production decay ratio?","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Turnover.DPC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extracts Root Decay, New Root Production, and No-Change Roots. Relies on 'RootDetector' — Turnover.DPC","text":"either pixel sums im.return = F, individual layers corresponding tape, production, decay, change","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Turnover.DPC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extracts Root Decay, New Root Production, and No-Change Roots. Relies on 'RootDetector' — Turnover.DPC","text":"","code":"data(TurnoverDPC_data) img = terra::rast(TurnoverDPC_data) DPCs = Turnover.DPC(img = img, im.return = FALSE)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Turnover.TC.html","id":null,"dir":"Reference","previous_headings":"","what":"Global root production and root turnover from temporal comparison — Turnover.TC","title":"Global root production and root turnover from temporal comparison — Turnover.TC","text":"Global root production root turnover temporal comparison","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Turnover.TC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Global root production and root turnover from temporal comparison — Turnover.TC","text":"","code":"Turnover.TC(im.t1, im.t2, method = \"kimura\", unit = \"cm\", dpi = 300)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Turnover.TC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Global root production and root turnover from temporal comparison — Turnover.TC","text":"im.t1 brick raster timepoint 1 im.t2 brick raster timepoint 2 method choose \"kimura\" & \"rootpx\". Adjust input image accordingly unit unit root length. applies method = \"kimura\" dpi image resolution. applies method = \"kimura\"","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Turnover.TC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Global root production and root turnover from temporal comparison — Turnover.TC","text":"standing roots start, standing roots end, root production,","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Turnover.TC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Global root production and root turnover from temporal comparison — Turnover.TC","text":"Chosing kimura method return root length default settings RootLength()","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/Turnover.TC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Global root production and root turnover from temporal comparison — Turnover.TC","text":"","code":"data(skl_Oulanka2023_Session01_T067) data(skl_Oulanka2023_Session03_T067) time1 = terra::rast(skl_Oulanka2023_Session01_T067) time2 = terra::rast(skl_Oulanka2023_Session03_T067) turnover.values = Turnover.TC(im.t1 = time1, im.t2 = time2, method= \"kimura\")"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/TurnoverDPC_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Turnover Estimation of Individual Roots from ","title":"Turnover Estimation of Individual Roots from ","text":"image derived rgb root scan using \"RootDetector\" segment compare second time point using root tracking feature. Roots represented max value, Background = 0. First layer shows root decay (disappeared time points), foreign objects tape, -change roots Second Layer shows new root growth -change roots Third Layer shows -change-roots scan originates sedge fen northern Finland. Columns correspond tube length rows tube rotation","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/TurnoverDPC_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turnover Estimation of Individual Roots from ","text":"","code":"data(TurnoverDPC_data)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/TurnoverDPC_data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Turnover Estimation of Individual Roots from ","text":"RasterBrick 2550 columns x 2273 rows x 3 layer","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/TurnoverDPC_data.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Turnover Estimation of Individual Roots from ","text":"Images J.Cunow","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/TurnoverDPC_data.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Turnover Estimation of Individual Roots from ","text":"Johannes Cunow johannes.cunow@gmail.com","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest.html","id":null,"dir":"Reference","previous_headings":"","what":"Finite sample/ Large sample Wald test for circadian pattern detection — WaldTest","title":"Finite sample/ Large sample Wald test for circadian pattern detection — WaldTest","text":"Test significance circadian curve fitting using finite sample Wald test","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finite sample/ Large sample Wald test for circadian pattern detection — WaldTest","text":"","code":"WaldTest(tt, yy, period = 24, FN = TRUE)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finite sample/ Large sample Wald test for circadian pattern detection — WaldTest","text":"tt Time vector yy Expression vector period Period since curve. Default 24. FN Type test use, TRUE = \"FN\" (finite) FALSE = \"LS\" (large samples). Default finite sample.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finite sample/ Large sample Wald test for circadian pattern detection — WaldTest","text":"list , B, offset, df, stat, pvalue Formula 1: \\(yy = amp \\times sin(2\\pi/period \\times (phase + tt)) + offset\\) Formula 2: \\(yy = \\times sin(2\\pi/period \\times tt) + B * cos(2*pi/period * tt) + offset\\) based formula 2 B B based formula 2 amp Amplitude based formula 1 phase Phase based formula 1, phase restricted within (0, period) peakTime Phase based formula 1, peakTime restricted within (0, period). phase + peakTime = period/4 offset Basal level based formula 1 formula 2 df Degree freedom Wald test stat Wald statistics pvalue P-value Wald test R2 Pseudo R2 defined (tss - rss)/tss","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finite sample/ Large sample Wald test for circadian pattern detection — WaldTest","text":"Caleb","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finite sample/ Large sample Wald test for circadian pattern detection — WaldTest","text":"","code":"set.seed(32608) n <- 50 Period <- 24 tt <- runif(n,0,Period) Amp <- 2 Phase <- 6 Offset <- 3 yy <- Amp * sin(2*pi/Period * (tt + Phase)) + Offset + rnorm(n,0,1) WaldTest(tt, yy) #> $amp #> [1] 1.915422 #>  #> $phase #> [1] 6.536394 #>  #> $peakTime #> [1] 23.46361 #>  #> $offset #> [1] 3.028329 #>  #> $stat #> [1] 84.06316 #>  #> $pvalue #> [1] 2.992272e-16 #>  #> $R2 #> [1] 0.7815237 #>"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_amp.html","id":null,"dir":"Reference","previous_headings":"","what":"Finite sample/Large sample Wald test for differential amplitude. — WaldTest_diff_amp","title":"Finite sample/Large sample Wald test for differential amplitude. — WaldTest_diff_amp","text":"Test differential amplitude circadian curve fitting using Wald test","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_amp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finite sample/Large sample Wald test for differential amplitude. — WaldTest_diff_amp","text":"","code":"WaldTest_diff_amp(tt1, yy1, tt2, yy2, period = 24, FN = TRUE)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_amp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finite sample/Large sample Wald test for differential amplitude. — WaldTest_diff_amp","text":"tt1 Time vector condition 1 yy1 Expression vector condition 1 tt2 Time vector condition 2 yy2 Expression vector condition 2 period Period since curve. Default 24. FN Type test use, TRUE = \"FN\" (finite) FALSE = \"LS\" (large samples). Default finite sample.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_amp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finite sample/Large sample Wald test for differential amplitude. — WaldTest_diff_amp","text":"list, see details . Formula 1: \\(yy = amp \\times sin(2\\pi/period \\times (phase + tt)) + offset\\) Formula 2: \\(yy = \\times sin(2\\pi/period \\times tt) + B * cos(2*pi/period * tt) + offset\\) amp_1 Amplitude estimate 1st data amp_2 Amplitude estimate 2nd data amp_c Amplitude estimate pooling data together df Degree freedom Wald test stat Wald statistics pvalue P-value Wald test","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_amp.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finite sample/Large sample Wald test for differential amplitude. — WaldTest_diff_amp","text":"Caleb","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_amp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finite sample/Large sample Wald test for differential amplitude. — WaldTest_diff_amp","text":"","code":"set.seed(32608) n <- 50 Period <- 24 tt1 <- runif(n,0,Period) Amp1 <- 2 Phase1 <- 6 Offset1 <- 3 yy1 <- Amp1 * sin(2*pi/Period * (tt1 + Phase1)) + Offset1 + rnorm(n,0,1) tt2 <- runif(n,0,Period) Amp2 <- 3 Phase2 <- 5 Offset2 <- 2 yy2 <- Amp2 * sin(2*pi/Period * (tt2 + Phase2)) + Offset2 + rnorm(n,0,1) WaldTest_diff_amp(tt1, yy1, tt2, yy2) #> $amp_1 #> [1] 1.915422 #>  #> $amp_2 #> [1] 3.210351 #>  #> $amp_c #> [1] 2.310434 #>  #> $stat #> [1] 27.32011 #>  #> $pvalue #> [1] 2.009222e-06 #>"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_offset.html","id":null,"dir":"Reference","previous_headings":"","what":"Finite sample/Large sample Wald test for differential basal level (vertical shift). — WaldTest_diff_offset","title":"Finite sample/Large sample Wald test for differential basal level (vertical shift). — WaldTest_diff_offset","text":"Test differential basal level circadian curve fitting using Wald test","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_offset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finite sample/Large sample Wald test for differential basal level (vertical shift). — WaldTest_diff_offset","text":"","code":"WaldTest_diff_offset(tt1, yy1, tt2, yy2, period = 24, FN = TRUE)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_offset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finite sample/Large sample Wald test for differential basal level (vertical shift). — WaldTest_diff_offset","text":"tt1 Time vector condition 1 yy1 Expression vector condition 1 tt2 Time vector condition 2 yy2 Expression vector condition 2 period Period since curve. Default 24. FN Type test use, TRUE = \"FN\" (finite) FALSE = \"LS\" (large samples). Default finite sample.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_offset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finite sample/Large sample Wald test for differential basal level (vertical shift). — WaldTest_diff_offset","text":"list, see details . Formula 1: \\(yy = amp \\times sin(2\\pi/period \\times (phase + tt)) + offset\\) Formula 2: \\(yy = \\times sin(2\\pi/period \\times tt) + B * cos(2*pi/period * tt) + offset\\) offset_1 Basal level estimate 1st data offset_2 Basal level estimate 2nd data offset_c Basal level estimate pooling data together df Degree freedom Wald test stat Wald statistics pvalue P-value Wald test","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_offset.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finite sample/Large sample Wald test for differential basal level (vertical shift). — WaldTest_diff_offset","text":"Caleb","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_offset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finite sample/Large sample Wald test for differential basal level (vertical shift). — WaldTest_diff_offset","text":"","code":"set.seed(32608) n <- 50 Period <- 24 tt1 <- runif(n,0,Period) Amp1 <- 2 Phase1 <- 6 Offset1 <- 3 yy1 <- Amp1 * sin(2*pi/Period * (tt1 + Phase1)) + Offset1 + rnorm(n,0,1) tt2 <- runif(n,0,Period) Amp2 <- 3 Phase2 <- 5 Offset2 <- 2 yy2 <- Amp2 * sin(2*pi/Period * (tt2 + Phase2)) + Offset2 + rnorm(n,0,1) WaldTest_diff_offset(tt1, yy1, tt2, yy2) #> $offset_1 #> [1] 3.028329 #>  #> $offset_2 #> [1] 1.725023 #>  #> $offset_c #> [1] 2.676353 #>  #> $stat #> [1] 58.32873 #>  #> $pvalue #> [1] 5.550208e-11 #>"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_phase.html","id":null,"dir":"Reference","previous_headings":"","what":"Finite sample/Large sample Wald test for differential phase. — WaldTest_diff_phase","title":"Finite sample/Large sample Wald test for differential phase. — WaldTest_diff_phase","text":"Test differential phase circadian curve fitting using Wald test","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_phase.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finite sample/Large sample Wald test for differential phase. — WaldTest_diff_phase","text":"","code":"WaldTest_diff_phase(tt1, yy1, tt2, yy2, period = 24, FN = TRUE)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_phase.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finite sample/Large sample Wald test for differential phase. — WaldTest_diff_phase","text":"tt1 Time vector condition 1 yy1 Expression vector condition 1 tt2 Time vector condition 2 yy2 Expression vector condition 2 period Period since curve. Default 24. FN Type test use, TRUE = \"FN\" (finite) FALSE = \"LS\" (large samples). Default finite sample.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_phase.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finite sample/Large sample Wald test for differential phase. — WaldTest_diff_phase","text":"list, see details . Formula 1: \\(yy = amp \\times sin(2\\pi/period \\times (phase + tt)) + offset\\) Formula 2: \\(yy = \\times sin(2\\pi/period \\times tt) + B * cos(2*pi/period * tt) + offset\\) phase_1 Phase estimate 1st data, phase restricted (0, period) phase_2 Phase estimate 2nd data, phase restricted (0, period) phase_c Phase estimate pooling data together, phase restricted (0, period) df Degree freedom Wald test stat Wald statistics pvalue P-value Wald test","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_phase.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finite sample/Large sample Wald test for differential phase. — WaldTest_diff_phase","text":"Caleb","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_phase.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finite sample/Large sample Wald test for differential phase. — WaldTest_diff_phase","text":"","code":"set.seed(32608) n <- 50 Period <- 24 tt1 <- runif(n,0,Period) Amp1 <- 2 Phase1 <- 6 Offset1 <- 3 yy1 <- Amp1 * sin(2*pi/Period * (tt1 + Phase1)) + Offset1 + rnorm(n,0,1) tt2 <- runif(n,0,Period) Amp2 <- 3 Phase2 <- 5 Offset2 <- 2 yy2 <- Amp2 * sin(2*pi/Period * (tt2 + Phase2)) + Offset2 + rnorm(n,0,1) WaldTest_diff_phase(tt1, yy1, tt2, yy2) #> $phase_1 #> [1] 6.536394 #>  #> $phase_2 #> [1] 5.399322 #>  #> $phase_c #> [1] 5.797734 #>  #> $stat #> [1] 8.523932 #>  #> $pvalue #> [1] 0.005681205 #>"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_sigma2.html","id":null,"dir":"Reference","previous_headings":"","what":"Finite sample/Large sample Wald test for differential sigma square. — WaldTest_diff_sigma2","title":"Finite sample/Large sample Wald test for differential sigma square. — WaldTest_diff_sigma2","text":"Test differential sigma square circadian curve fitting using Wald test","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_sigma2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finite sample/Large sample Wald test for differential sigma square. — WaldTest_diff_sigma2","text":"","code":"WaldTest_diff_sigma2(tt1, yy1, tt2, yy2, period = 24, FN = TRUE)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_sigma2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finite sample/Large sample Wald test for differential sigma square. — WaldTest_diff_sigma2","text":"tt1 Time vector condition 1 yy1 Expression vector condition 1 tt2 Time vector condition 2 yy2 Expression vector condition 2 period Period since curve. Default 24. FN Type test use, TRUE = \"FN\" (finite) FALSE = \"LS\" (large samples). Default finite sample.","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_sigma2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finite sample/Large sample Wald test for differential sigma square. — WaldTest_diff_sigma2","text":"list, see details . Formula 1: \\(yy = amp \\times sin(2\\pi/period \\times (phase + tt)) + offset\\) Formula 2: \\(yy = \\times sin(2\\pi/period \\times tt) + B * cos(2*pi/period * tt) + offset\\) sigma2_1 Variance estimate 1st data sigma2_2 Variance estimate 2nd data sigma2_C Variance estimate pooling data together df Degree freedom Wald test stat Wald statistics pvalue P-value Wald test","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_sigma2.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finite sample/Large sample Wald test for differential sigma square. — WaldTest_diff_sigma2","text":"Caleb","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/WaldTest_diff_sigma2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finite sample/Large sample Wald test for differential sigma square. — WaldTest_diff_sigma2","text":"","code":"set.seed(32608) n <- 50 Period <- 24 tt1 <- runif(n,0,Period) Amp1 <- 2 Phase1 <- 6 Offset1 <- 3 yy1 <- Amp1 * sin(2*pi/Period * (tt1 + Phase1)) + Offset1 + rnorm(n,0,1) tt2 <- runif(n,0,Period) Amp2 <- 3 Phase2 <- 5 Offset2 <- 2 yy2 <- Amp2 * sin(2*pi/Period * (tt2 + Phase2)) + Offset2 + rnorm(n,0,1) WaldTest_diff_sigma2(tt1, yy1, tt2, yy2) #> $sigma2_1 #> [1] 0.5463823 #>  #> $sigma2_2 #> [1] 0.9414007 #>  #> $sigma2_c #> [1] 0.7438915 #>  #> $stat #> [1] 3.524727 #>  #> $pvalue #> [1] 0.07190605 #>"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/zone.fun.html","id":null,"dir":"Reference","previous_headings":"","what":"Cuts out a zone of interest — zone.fun","title":"Cuts out a zone of interest — zone.fun","text":"Cuts zone interest","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/zone.fun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cuts out a zone of interest — zone.fun","text":"","code":"zone.fun(rootpic, binned.map, indexD = 0, nn = 5, silent = FALSE)"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/zone.fun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cuts out a zone of interest — zone.fun","text":"rootpic image cut binned.map image supplies cut condition indexD condition nn bin width binned.map. used 'binning()' silent verbose","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/zone.fun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cuts out a zone of interest — zone.fun","text":"cutout root pic image","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/zone.fun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cuts out a zone of interest — zone.fun","text":"","code":"data(seg_Oulanka2023_Session01_T067) img = terra::rast(seg_Oulanka2023_Session01_T067[[2]]) mask = seg_Oulanka2023_Session01_T067[[1]] - seg_Oulanka2023_Session01_T067[[2]] mask[mask == 255] <- NA depthmap = create.depthmap(img,mask,start.soil = 290 ) binned.map = binning(depthmap,nn = 5) image.zone = zone.fun(img, binned.map, indexD = 0, nn=5, silent = FALSE) #> [1] \"Depth: 0cm. Not enough informative pixels. In the whole Image, 93% are NAs after cutting this Depth Slice. Expected NA% is: ~83.33\""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/zone.rotation.fun.html","id":null,"dir":"Reference","previous_headings":"","what":"RotationZones — zone.rotation.fun","title":"RotationZones — zone.rotation.fun","text":"RotationZones","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/zone.rotation.fun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RotationZones — zone.rotation.fun","text":"","code":"zone.rotation.fun(rootpic, k = c(3, 4), kk = 5, mm = c(2000, 5000))"},{"path":"https://jcunow.github.io/MinirhizotronR/reference/zone.rotation.fun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"RotationZones — zone.rotation.fun","text":"rootpic \"cut\" image k specify cuts keep. Must <= nn kk number total cuts along rotation axis mm limit region along tube = c(start,end). Adjust tube dimensions!","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/zone.rotation.fun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"RotationZones — zone.rotation.fun","text":"raster, cut along rotation axis","code":""},{"path":"https://jcunow.github.io/MinirhizotronR/reference/zone.rotation.fun.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"RotationZones — zone.rotation.fun","text":"","code":"data(seg_Oulanka2023_Session01_T067) img = terra::rast(seg_Oulanka2023_Session01_T067) rotationZone = zone.rotation.fun(img, k = c(1,2), kk = 7, mm = c(1500,3000))"},{"path":"https://jcunow.github.io/MinirhizotronR/news/index.html","id":"minirhizotronr-010","dir":"Changelog","previous_headings":"","what":"MinirhizotronR 0.1.0","title":"MinirhizotronR 0.1.0","text":"Initial CRAN submission.","code":""}]
