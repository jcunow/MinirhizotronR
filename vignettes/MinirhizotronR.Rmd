---
title: "MinirhizotronR: Depth Resolved Analysis of Segmented Minirhizotron Scans"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

```

```{r setup}
knitr::opts_chunk$set(include = FALSE)
library(MinirhizotronR)
library(cowplot)
library(ggplot2)
library(dplyr)
```

## Description: 
This package is designed in support a analysis of root scans from Minirhizotron tubes, starting after image segmentation.
The following is needed to use this package to it's full potential:
    
    
*mandatory:* 

- raw root scans
- segmentation of root scans
- tube insertion angle and tube thickness

*optional:*

- skeletonized version of root scans, 
- *in-situ* calibration of soil surface to image start & rotation calibration is recommended!

*suggestion:* 

- use 'RootDetector' or an equivalent Image segmentation convolutional neural net to aid in automated analysis of root scans beforehand.
- use AffineStitcher.py or equivalent to stitch all individual scans belonging to a particular tube in time to generate unified images




## Install Package
```{r Install Package}
# devtools::install_git("jcunow/MinirhizotronR")
# remotes::install_github("jcunow/MinirhizotronR")
```


## First Step - Prep
Stitch your images together and segment them. You can find on e solution to this here: ....Link


## Second Step - Prep
Segment the stitched Image. You can use this: ....Link
Tipp: use split_im() function to cut the root image in pieces in case 'RootDetetcor' has trouble with the amount of roots of roots. You can rejoin the segmented images afterwards with join_im(). But first, look change the settings of 'RootDetector' and crank up the maximum root limit.  

```{r Input Example Showcase, fig.height=4.9, fig.width=9, message=FALSE, warning=FALSE, paged.print=FALSE}
p1 <- ggdraw() + draw_image(paste0(getwd(),"/demo_images/Oulanka2023_Session03_T067.jpg"), scale = 0.9)
p2 <- ggdraw() + draw_image(paste0(getwd(),"/demo_images/Oulanka2023_Session03_T067_segmented.jpg"), scale = 0.9)
p3 <- ggdraw() + draw_image(paste0(getwd(),"/demo_images/Oulanka2023_Session03_T067_skeleton.jpg"),scale = 0.9)

plot_grid(p1, p2, p3,nrow = 3)
```


## Third step - The Package begins
Now we are finally ready to start using the package.
First, we need to load the images and then estimate the soil surface and the rotation.
```{r Start the package, echo=FALSE,  warning=FALSE}
library(MinirhizotronR)
library(dplyr)
# read tiffs
img.color = raster::brick(paste0(getwd(),"/demo_images/Oulanka2023_Session03_T067.tiff"))
img.segm  = raster::brick(paste0(getwd(),"/demo_images/Oulanka2023_Session03_T067_segmented.tiff"))
img.skel  = raster::brick(paste0(getwd(),"/demo_images/Oulanka2023_Session03_T067_skeleton.tiff"))


```

## Now, we need to define where the soil begins
```{r Meta-Data, echo=FALSE,  warning=FALSE}
  
### If you have measured the the distance from the soil to the edge of the tube - great, your job is done! 
## Just do this:
height = 12 # cm
tilt = 45 # insertion angle
dpi = 300 # imiage resolution

# law of sines
radiant = pi/180
s0.true = (sin((90) * radiant)*height) / sin(tilt * radiant)
s0 = s0.true * dpi / 2.54
s0 = s0 %>% round()


### If you don't have any data meta-deta available - too bad!
## Try this instead:
# Based on Tape Cover, soil start is estimated
s0 = MinirhizotronR::SoilSurfE(img.color)
print(paste0("Soil Surface Beginning in columns: ",s0$soil0))
# While we're at it, lets estimate the rotion center (Here, we assume that the tape extrusion on the upside of the Tube is perfectly centered - go and calibrate !!!)
r0 = MinirhizotronR::RotationE(img.color)
print(paste0("Rotation Center in rows: ",r0))
```



```{r Create a depthmap, echo=FALSE, fig.height=4, fig.width=1.5, warning=FALSE}
### We are ready now to create a depth map. The here goal is to supply every pixel of the root scans with a depth information. We choose to include the tube thickness and thereby create a phase shifted cosine depth map  -  or ignore it  (as traditionally done). Ignoring it will create a map in which the tube upside is located the same depth as tube downside (= vertical insertion angle). 

## We want to exclude pixels with tape as part of the soil. Create a mask:
# The format of 'RootDetector' uses the red channel to show mask and root px, while blue and green only show root px
mask = (img.segm[[1]] - img.segm[[2]] ) / 255
mask = raster::t(mask)
## Create the Map (cosine.option missing!)
center.offset = r0  / dim(img.segm)[1]
DepthMap = MinirhizotronR::create.depthmap(im = img.segm, mask = mask,start.soil = s0$soil0, center.offset = center.offset )

# Now lets bin the depth to be able to calculate some stats. Analysis on continous depth will feature in a future release.
# we use 5cm intervals here but any bandwidth can be used.
bm = MinirhizotronR::binning(DepthMap, nn = 5)
raster::extent(bm) <- c(0,dim(bm)[2],0,dim(bm)[1])
# Binned Depthmap Plot
RStoolbox::ggR(bm)+theme_void()

```

## With Depth Information ready, we can now analyze the data. Here, we are interested in 3 key features: Root Coverage, RootScapes Features, and Peat Characteristics. Lets get to the vegan meat of it:
```{r Depth Stats, fig.height=3, fig.width=4.2, , warning=FALSE}
# A good starting point is selecting the desired depth. Typically, you want to go through all depth to construct a depth distribution. For brevity, we show it for one depth here.

## We only need one binarized layer
# one layer gray would usually be a good option, however, there is distinct information stored in the various layers when using 'RootDetector'
gray.roots = rgb2gray(img.segm)
# In this format, we can simply do this:
gray.roots = img.segm[[2]] / 255

# extracts a depth band from the root image based on the depth map 
rootzone = zone.fun(rootpic = gray.roots, binned.map = bm, indexD = -10, nn = 5 )
# the output message tells us the there are not enough proper values in the root zone. Lets try again
rootzone = zone.fun(rootpic = gray.roots, binned.map = bm, indexD = 20, nn = 5 )
raster::extent(rootzone) <- c(0,dim(rootzone)[2],0,dim(rootzone)[1])
RStoolbox::ggR(rootzone) + theme_void()
# Also do it for the skeletonized version
rootzone.skeleton = zone.fun(img.skel[[2]], binned.map = bm, indexD = 20, nn = 5)
raster::extent(rootzone.skeleton) <- c(0,dim(rootzone.skeleton)[2],0,dim(rootzone.skeleton)[1])


# Get the landscape metrics of the root scape - keep the output units in mind (assuming... input and deliver hectar output)
rsm = RootScapeMetrics(rootzone,indexD = 20, metrics = c( "lsm_c_ca","lsm_l_ent","lsm_c_pd","lsm_c_np","lsm_c_pland",
                                      "lsm_c_area_mn","lsm_c_area_cv","lsm_c_enn_mn","lsm_c_enn_cv")) 
print(rsm) 



```

## Get Root Coverage
```{r}

# Get number of Root pixel and Root Length, and Root Thickness
void = gray.roots  
raster::values(void) = 1-raster::values(gray.roots)
# check if extent matches

# rotate if necessary
if(all(dim(bm)[1:2] != dim(gray.roots)[1:2])){
bm = raster::t(bm)  
}

# retrieve the root pixel sum and the pixel without roots for all depths
void.sum = raster::zonal( void,bm, "sum" )
root.sum = raster::zonal(gray.roots,bm,"sum")
# if you want to include this function within a depth wise loop use this
rootpixel = px.sum(root.zone = rootzone) # uses the segmented - so its total root pixel


# for root length do something like this
kimroot = RootLength(rootzone.skeleton)
# lastly Root thickness
root.thicc = root.thickness(kimuralength = kimroot, rootpx = rootpixel, dpi = 300)

## report:
print(paste0("total root pixel in this depth: ",rootpixel," px"))
print(paste0("total root length in this depth: ",kimroot," cm"))
print(paste0("average root thickness in this depth: ",root.thicc," cm"))
```
## OBS! not all depth have equal amount of tube surface to display roots! The end pieces of the tilted tube and partially tape covered tube have smaller tube surface
```{r}
# correct for available space
av.space = root.sum + void.sum
av.space[,1] =  av.space[,1]/2
plot(av.space) + title("total available rooting space")

rootpx_per_av.space =  root.sum
rootpx_per_av.space[,2] = root.sum[,2] / av.space[,2]
df.rootpx_per_av.space = as.data.frame(rootpx_per_av.space)
ggplot(data=df.rootpx_per_av.space,aes(zone+5,sum)) + geom_point() + geom_smooth(span=0.25) + theme_classic() + ylab("% covered by roots") + xlab("Depth [cm]") +ggtitle("Roots per available rooting space")
#ggsave("C:/Users/jocu0013/Documents/GitHub/MinirhizotronR/figures/rootsperavailablespace.png")  
```

## what if we want to consider a sphere of influence around the roots ?
```{r}
## set hard limits
root.seg = gray.roots
raster::values(root.seg)[raster::values(raster::t(mask))==1] <- NA

# create a buffer around pixels (12 px == ca. 1mm)
buff.im = Halo(root.seg, width = 4, halo.only = FALSE)
RStoolbox::ggR(buff.im) + ggtitle("The sphere of influence (roots + 0.3mm each side)") 


## lets do some stats on the sphere of influence
buffer.sum = raster::zonal( buff.im,bm, "sum" )
plot(scale(buffer.sum)); points(scale(root.sum),col="red") + title("The difference between distribution of influence (black) vs distribution of rotos (red)")

# Hint: sphere of influence might not be the same across depth with varying physiology and hydraulic conductivity
```





Can we characterize the Peat too ?
```{r}
# only consider soil pixels - not tape nor roots
peat.color = raster::crop(img.color,gray.roots)
raster::values(peat.color)[raster::values(buff.im) == 1] = NA 
raster::values(peat.color)[raster::values(raster::t(mask)) == 1] = NA 
# plot & color
RStoolbox::ggR(peat.color)
tube.color.peat = Tube.coloration(peat.color);tube.color.peat


# now only consider roots
root.color = raster::crop(img.color,gray.roots)
raster::values(root.color)[raster::values(gray.roots) == 0] = NA 
raster::values(root.color)[raster::values(raster::t(mask)) == 1] = NA 
# plot & color
RStoolbox::ggR(root.color) + ggtitle("available root pixel")
tube.color.root = Tube.coloration(root.color);tube.color.root

##  Lets try to get texture information as well
gray.peat = rgb2gray(peat.color)
void.tx = glcm::glcm(gray.peat,n_grey = 7,window = c(9,9), 
                     statistics = c("second_moment","homogeneity","entropy"),
                     shift=list(c(0,1), c(1,1), c(1,0), c(1,-1)))
RStoolbox::ggR(void.tx[[1]]) + ggtitle("available texture pixels and their second moment characteristic ")
tx.mean = raster::zonal(void.tx[[1]],bm,"mean")
plot(tx.mean) + title("second moment - peat texture characterization")
```


### as the tube insertion angle increases, the more we expect a differences between the upside of the tube and the downside. Let's estimate the rotational bias
```{r Asess Rotational Bias}
# lets make the split in 1 cm intervals
splits = round(dim(root.color)[1]/300*2.54)
rot.df = data.frame(rotation = 1:splits,rotation.rootpx = NA)

for (k in 1:splits) {
rotation.z = zone.rotation.fun(rootpic = root.seg, mm= c(4000,9000), nn = splits, k = c(k-1,k))  
rot.df[k,2] = px.sum(root.zone = rotation.z)
}
rot.df$sc.rotationpx = scale(rot.df$rotation.rootpx)
ggplot(data= rot.df, aes(rotation,sc.rotationpx)) + geom_point() +  theme_bw() + xlab("rotation cm") + ylab("root px") + geom_smooth(method="lm", formula = y ~ cos(x*pi/8),method.args = list(start=c(b=8)),aes(color = "cosine fit")) + geom_smooth(se=F,aes(color="local smooth"))

## fit a sine curve to the rotation-sliced image
fitSinCurve(tt=rot.df$rotation,yy=rot.df$sc.rotationpx)
# test if the variation in the data is 0 or explained by sine function alone 
ryth.test = LR_rhythmicity(tt=rot.df$rotation,yy=rot.df$sc.rotationpx,period = 19, method = "LR")
(6.35*pi) - ryth.test$phase 

## if tow tubes are ought to be compared (different insertion angles or tube diameter)
WaldTest_diff_amp(tt1=rot.df$rotation,yy1=rot.df$sc.rotationpx,tt2=rot.df$rotation,yy2=rot.df$sc.rotationpx+runif(length(rot.df$rotation)))


## we can also test if if the rotational root distribution corresponds to the true tube upside
# rotation segments
RStoolbox::ggR(root.seg) + 
  geom_hline(yintercept = seq(0,dim(root.seg)[1],length = splits+1),
             color = "red",size=0.05,linetype = "solid") + 
  theme_void() + 
  geom_text(label = 1:20,aes(x=250,
                                 y= (scale((seq(0,dim(root.seg)[1],
                                                length = splits)))*
                                    (sd((seq(0,dim(root.seg)[1]-(dim(root.seg)[1]/splits),
                                             length =splits))))) + 
                                   mean((seq(0,dim(root.seg)[1],
                                             length = splits)))),
            color="black",size=1.5) 
#ggsave("C:/Users/jocu0013/Documents/GitHub/MinirhizotronR/figures/rotation_splicing.png")

# based on rotation center determined previously
df1 = seq(0*pi,-2*pi,-2*pi/(max(rot.df$rotation)-1))
calibrated.phase = (cos(df1+(pi*(1-center.offset))))*(6.35/2)
# test the rotational root distribution vs the calibrated
difftest = LRTest_diff_phase(tt1 = rot.df$rotation, tt2 =  rot.df$rotation, yy1 = calibrated.phase, yy2 = rot.df$sc.rotationpx,
                  period = round(pi*6.35));difftest
# tape estimation did not reflect the center of root distribution

## alternative polar plot
rot.df<-rot.df%>%
    mutate(
        # Use (rotation-0.5), not just id, to center label on each item
        angle=90-360*(rotation-0.5)/max(rotation)
    ) %>%
  mutate(exag.rootpx = rotation.rootpx**1.75)


ggplot(data= rot.df, 
       aes(rotation-ryth.test$peakTime,exag.rootpx)) + 
  geom_bar(fill="indianred",
           stat = "identity") + 
    geom_text(data=rot.df,
            aes(y=max(exag.rootpx)-max(exag.rootpx)*0.925,label=rotation),hjust = 0.5, size = 3,color = "white")+
  theme_minimal()+
  ylab("")+xlab("")+
  scale_y_continuous(breaks = c(-max(rot.df$exag.rootpx)*0.1),
                                       labels = "",
                                       limits = c(
     -max(rot.df$exag.rootpx)/1.25,
     max(rot.df$exag.rootpx)*1
   ))+
 scale_x_continuous(labels = "",breaks = max(rot.df$exag.rootpx))+
coord_polar(start= (max(rot.df$rotation)/2 - 0.5)-(ryth.test$phase - ryth.test$peakTime) )
#ggsave("C:/Users/jocu0013/Documents/GitHub/MinirhizotronR/figures/rotation_bias.png")
```

## Now its time for Turnover
```{r}
# the package offers two methods two estimate turnover. 
#The function Turnover.TC() makes a comparison between two timepoints and determines production in relation to total biomass. 
 im1 = raster::raster("C:/Users/jocu0013/Desktop/Oulanka/Scans_FullSkeleton/Oulanka2023_01/FullSegmented_Oulanka2023_Session01_T037.tiff.skeleton.png.tiff")
 im2 = raster::raster("C:/Users/jocu0013/Desktop/Oulanka/Scans_FullSkeleton/Oulanka2023_03/FullSegmented_Oulanka2023_Session03_T037.tiff.skeleton.png.tiff")
turn1 = Turnover.TC(im1,im2,method = "kimura");turn1
# PDC stands for production, decay, and constant - extracting the variables from a 'RootDetector' format turnover output
im1 = raster::brick("C:/Users/jocu0013/Desktop/Oulanka/Scan_comparsion/turnover2023/Split_top_Oulanka2023_T067_L001_turn.png")
turn2 = Turnover.PDC(im1, product.layer = 2, decay.layer = 1);turn2
# we can also return production, decay, and constant layers instead and go apply depth stats
turn3 = Turnover.PDC(im1, im.return = T)
# adapt depth map

bm.turn = RotCensor(bm)
bm.turn2 = DepthLimiter(bm.turn,top.cut = F)
#bm.turn2 =raster::raster(bm.turn2)
raster::extent(bm.turn2) = raster::extent(turn3$production)
prd = raster::zonal(turn3$production,bm.turn2,"sum")
dec = raster::zonal(turn3$decay,bm.turn2,"sum")
con = raster::zonal(turn3$constant,bm.turn2,"sum")

df = data.frame(prd = prd[,2],dec =  dec[,2],con =  con[,2], x = prd[,1], rootpx = root.sum[2:(length(prd[,1])+1),2])
ggplot(data=df,aes(x=x)) + 
  scale_y_continuous(limits = c(0,1))+
  scale_x_continuous(limits = c(0,40))+
  theme_bw()+
  geom_point(aes(y = prd/rootpx,color = "prd")) + geom_line(aes(y = prd/rootpx,color = "prd")) + 
  geom_point(aes(y = dec/rootpx,color = "dec")) + geom_line(aes(y = dec/rootpx,color = "dec")) + 
  geom_point(aes(y = con/rootpx,color = "con")) + geom_line(aes(y = con/rootpx,color = "con"))# + geom_point(aes(y = rootpx,color = "rootpx")) + geom_line(aes(y = rootpx,color = "rootpx"))
```



```{r a quick and dirty fix to bring dimensions to the same level}
dir = "C:/Users/jocu0013/Desktop/Oulanka/Scan_comparsion/2023_01/"
#dir.out = dir
dir.out = "C:/Users/jocu0013/Desktop/Oulanka/Scan_comparsion/censor_2023_01/"
 file.names = list.files(dir)[-1]
 for (i in file.names) {
   im = tiff::readTIFF(paste0(dir,i))
   name = i
   
   #name = stringr::str_replace(i, pattern = "_Session03_",replacement = "_")
   #name = stringr::str_replace(name, pattern = ".tiff",replacement = "_L001_03.tiff")
   
   # name = stringr::str_replace(i, pattern = "Split_dwn_O",replacement = "O")
   # name = stringr::str_replace(name, pattern = "Split_top_O",replacement = "O")
   # name = stringr::str_replace(name, pattern = "2023",replacement = "_2023")
 
   
    
    
    
    if(dim(im)[2] > 7200){
    im = DepthLimiter(im,fixed.depth = 7200)  
    }else{
      if(dim(im)[2] > 6100){
    im = DepthLimiter(im,fixed.depth = 6100)  
      }else{
    if(dim(im)[2] > 4900){
    im = DepthLimiter(im,fixed.depth = 4900)    
    }
    }
    }
   im = RotCensor(im)
 
   im = im / max(raster::values(im))
   im = raster::as.array(im)
   tiff::writeTIFF(im,paste0(dir.out,"/",name)) 
   
   
   print(i)
 }

```




